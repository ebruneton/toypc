% This work is licensed under the Creative Commons Attribution NonCommercial
% ShareAlike 4.0 International License. To view a copy of the license, visit
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\renewcommand{\rustfile}{chapter4}
\setcounter{rustid}{0}

\rust{
  context.write_backup("website/backups", "clock_driver.txt")?;
}

\chapter{Clock Driver}\label{chapter:clock}

Thanks to the virtual machine implemented in the previous chapter we can now
start to implement our basic input output system, in a much simpler way than
with machine code. Recall that our goal is to make the Arduino completely
autonomous, with its own keyboard and screen to write programs and run them
(instead of needing a host computer and a USB cable). For this we need small
programs to interact with the keyboard and the screen, called drivers. Before
writing them, however, it is useful to have a {\em clock driver}\footnote{This
is not strictly necessary. The clock driver could be written only once the
Arduino is autonomous, with the Arduino's keyboard and screen, but this would
be a bit more complex.}. That is, some functions to configure the Arduino's
clock and to wait for some time in a more precise way than with a software
counter.

This chapter presents the SAM3X8E components which are needed for this, namely
the Power Management Controller and the System Timer. We give an overview of
these components, and explain how programs can use them. We then use this
knowledge to implement the above clock driver functions. Finally, we test these
functions with a third version of our LED blinking program.

\section{Power Management Controller}\label{section:pmc}

The Power Management Controller (PMC) component generates clock signals for the
other components of the microcontroller, including the microprocessor and the
peripheral controllers (see \cref{fig:sam3x8e}). It can turn these clock
signals on and off, and can change their frequency. The higher the clock
frequency, the more power is consumed, but components whose clock signal is off
do not consume power. The Power Management Controller thus indirectly controls
how much power is consumed, hence its name.

The clock signals are generated by an oscillator circuit at a fixed frequency,
but can optionally go through other circuits which can multiply this frequency
by a configurable factor. The PMC has several such circuits. The ones used in
this book are represented in \cref{fig:pmc}:
\begin{itemize}
  \item The Resistor Capacitor (RC) is an oscillator circuit providing a 4MHz
  clock signal by default (it can be configured to output 4, 8 or 12MHz). It is
  integrated in the SAM3X8E chip.

  \item The Crystal Oscillator uses an external crystal on the Arduino board to
  generate a 12MHz clock signal. This signal is much more stable than the one
  provided by the Resistor Capacitor oscillator.

  \item The Phase Lock Loop (PLL) circuit can multiply the frequency output by
  the RC or by the Crystal oscillator by a configurable factor, up to 2048.
  Note however that the SAM3X8E components only support frequencies up to
  84MHz. Higher frequencies can damage them permanently.
\end{itemize}

\begin{Figure}
  \input{figures/chapter4/pmc.tex}

  \caption{A simplified representation of the Power Management Controller (PMC)
  circuit and registers (in gray). The PMC provides clock signals (in green) to
  the other components, generated from a selectable oscillator (left) at a
  frequency optionally multiplied by a configurable factor (middle). See
  Figures 28-1 and 28-2 in \cite{SAM3X8E}.}\label{fig:pmc}
\end{Figure}

These circuits are controlled by several registers. Some of them are shown in
\cref{fig:pmc}. The ones used in this book are presented below and in
\cref{table:pmc-registers}. The
full list of the PMC registers and its full diagram can be found in Chapter 28
of \cite{SAM3X8E}.

\subsection{Main Oscillator Register}

This register enables or disables the oscillator circuits, and selects which
oscillator to use. It has the following binary format (we present only the bits
that we use):

\begin{flushright}
\rs{PMC_MOR.bit_pattern(false)}
\end{flushright}

\begin{itemize}
  \item $r$ enables the RC oscillator if it is 1, and disables it otherwise.

  \item $c$ enables the Crystal Oscillator if it is 1, and disables it
  otherwise.

  \item $startup$ specifies the Crystal Oscillator start-up time, in quarters
  of milliseconds.

  \item $password$ must be \hexa{37}, otherwise writing into this register has
  no effect.

  \item $s$ selects the Crystal oscillator if it is 1, or the RC oscillator
  otherwise.
\end{itemize}

\subsection{Phase Lock Loop Register}

This register defines the frequency multiplication factor to use in the Phase
Lock Loop circuit. It has the following binary format:

\begin{flushright}
  \rs{PMC_PLLAR.bit_pattern(false)}
\end{flushright}

\begin{itemize}
  \item $multiplier$ and $divider$ configure the frequency multiplication
  factor. The PLL circuit multiplies the clock frequency by the fraction
  $(multiplier+1) / divider$. To use the PLL output as a clock signal,
  $divider$ must not be 0.

  \item $startup$ specifies the PLL circuit start-up time, in quarters
  of milliseconds.
\end{itemize}

\subsection{Master Clock Register}

This register defines which signal to use for the Master Clock, used by the
microprocessor and optionally by the peripheral controllers (see
\cref{fig:pmc}). It has the following binary format (we present only the bits
that we use):

\begin{flushright}
  \rs{PMC_MCKR.bit_pattern(false)}
\end{flushright}

\noindent The clock source selection ($css$) field can take four possible
values, but we use only two. If it is equal to 1, then the Master Clock is the
signal from the oscillator selected by the Main Oscillator Register. If it is 2
then the Master Clock is the output of the PLL circuit.

\begin{Table}
  \begin{tabular}{|l|l|l|}\hline
    \makecell{\thead{Name}} & \thead{Type} & \thead{Address} \\ \hline
    \makecell{Peripheral Clock Enable Register} & Write-Only &
    \rs{hex(PMC_PCER0)}
    \\
    \makecell{Peripheral Clock Disable Register} & Write-Only &
    \rs{hex(PMC_PCDR0)}
    \\
    \makecell{Peripheral Clock Status Register} & Read-Only &
    \rs{hex(PMC_PCSR0)} \\
    \makecell{Main Oscillator Register} & Read-Write &
    \rs{hex(PMC_MOR.address)} \\
    \makecell{Phase Lock Loop Register} & Read-Write &
    \rs{hex(PMC_PLLAR.address)} \\
    \makecell{Master Clock Register} & Read-Write & \rs{hex(PMC_MCKR.address)}
    \\
    \makecell{Status Register} & Read-Only & \rs{hex(PMC_SR.address)} \\ \hline
  \end{tabular}
  \caption{The Power Management Controller registers used in this
  book.}\label{table:pmc-registers}
\end{Table}

\subsection{Peripheral Clock Status Register}

This register gives the clock signal status of each peripheral component.
Peripherals are numbered, for instance the USART controller has number 17, the
SPI controller has number 24, etc (see \cref{fig:sam3x8e}). Bit number $i$
of this register indicates if the clock signal is enabled for peripheral
number $i$. If enabled, the same signal as the Master Clock is used (see
\cref{fig:pmc}). As the PIO Status Register, this register can only be read.
Writing to it has no effect. Instead, one must write in the Peripheral Clock
Enable Register (resp. the Peripheral Clock Disable Register) to set (resp.
clear) its bits.

\subsection{Status Register}

This read-only register indicates if the various clock signals inside the Power
Management Controller are ready to use or not. It has the following binary
format (we present only the bits that we use):

\begin{flushright}
  \rs{PMC_SR.bit_pattern(false)}
\end{flushright}

\begin{itemize}
  \item $c$ is 1 if the Crystal Oscillator is ready, or 0 otherwise. After the
  Crystal Oscillator is enabled with the Main Crystal Oscillator Register, one
  must wait until this bit is 1 before using the PMC again.

  \item $p$ is 1 if the PLL circuit output is ready, or 0 otherwise. After the
  frequency multiplier is changed with the Phase Lock Loop Register, one must
  wait until this bit is 1 before using the PMC again.

  \item $m$ is 1 if the Master Clock is ready, or 0 otherwise. After the clock
  source selection is changed with the Master Clock Register, one must wait
  until this bit is 1 before using the PMC again.

  \item $s$ is 1 if the oscillator selection is ready, or 0 otherwise. After
  the selected oscillator is changed (to the crystal or the RC oscillator), one
  must wait until this bit is 1 before using the PMC again.
\end{itemize}

\subsection{Configuration procedure}\label{subsection:pmc-config}

After a reset the PMC is configured to use the RC oscillator directly, without
going through the PLL circuit, and all the peripheral clocks are disabled. The
Master Clock thus runs at 4MHz by default. To use the maximum 84MHz frequency
instead, the following procedure can be used:
\begin{enumerate}
  \item enable the 12MHz Crystal Oscillator and wait for it to be ready,

  \item select the Crystal Oscillator and wait for this selection to be ready,

  \item set the PLL multiplier to 6 and its divider to 1, and wait for it to be
  ready,

  \item select the PLL output as the Master Clock source, and wait for it to be
  ready.
\end{enumerate}

Before doing this, however, the flash controllers must be configured as well.
Indeed the flash memory is slow. When the microprocessor sends a request to
read a value from it, it has to wait some time before it receives this value.
And the higher the clock frequency, the more it has to wait. This waiting time
is configured with the flash controller Mode Register (see
\cref{table:eefc-registers}). It has the following binary format (we present
only the bits that we use):

\begin{flushright}
  \rs{EEFC0_FMR.bit_pattern(false)}
\end{flushright}

\noindent The $wait$ field controls the above waiting time. According to Table
45-62 in \cite{SAM3X8E}, it must be at least 4 to use a 84MHz clock. And it
must be at least 6 when writing flash memory pages (see Section 49.1.1.1 in
\cite{SAM3X8E}).

\section{System Timer}\label{section:systick}

The System Timer (SysTick) is a 24-bit counter inside the Cortex M3
microprocessor (see \cref{fig:sam3x8e}). This counter is decremented by 1 every
8 cycles of the Master Clock, if it is enabled and not 0. If it is enabled and
equal to 0, it is instead reset to a configurable value called the {\em reload
value}.

This timer can be used to wait for a calibrated amount of time. For instance,
if the Master Clock is set to 84MHz, one can wait for 1 millisecond by
resetting the counter to $10500$ and by waiting until it is 0 ($10500*8$
cycles last $10500*8/84.10^6=10^{-3}$~s). The System Timer is
controlled with 3 registers, presented in \cref{table:systick-registers}:

\begin{itemize}
  \item The Control and Status Register enables or disables the timer, and
  indicates if it counted from 1 to 0 since the last time this register was
  read. It has the following binary format (we present only the bits that we
  use):

  \rs{SYSTICK_CTRL.bit_pattern(true)}

  The $e$ field enables the timer if it is 1, and disables it otherwise. The
  read-only $z$ field indicates if the timer counted to 0 since the last read
  of this register.

  \item The Reload Value Register specifies the reload value. Only its 24 least
  significant bits are used.

  \item The Current Value Register contains the counter's current value.
  Writing any value into this register resets this current value to 0 and also
  clears the $z$ field in the Control and Status Register. The counter is then
  reset to its reload value, if it is enabled, during one of the next 8 clock
  cycles.
\end{itemize}

\begin{Table}
  \begin{tabular}{|l|l|l|}\hline
    \makecell{\thead{Name}} & \thead{Type} & \thead{Address} \\ \hline
    \makecell{Control and Status Register} & Read-Write &
    \rs{hex(SYSTICK_CTRL.address)}
    \\
    \makecell{Reload Value Register} & Read-Write &
    \rs{hex(SYSTICK_LOAD.address)}
    \\
    \makecell{Current Value Register} & Read-Write &
    \rs{hex(SYSTICK_CURRENT.address)} \\ \hline
  \end{tabular}
  \caption{The System Timer registers used in this
  book.}\label{table:systick-registers}
\end{Table}

\section{Watchdog Timer}

Another microcontroller component which is related to time is the Watchdog
Timer. Its goal is to detect when the user application is stuck, for instance
because of a bug, and to reset the microcontroller if this happens. It does so
with a countdown until reset. In order to avoid being reset when the countdown
expires, the application must reinitialize it periodically, before it reaches
0. If the application crashes or enters an infinite loop, it cannot do this and
will thus eventually be reset. To avoid having to periodically reinitialize the
Watchdog Timer, we can simply disable it (it is enabled by default). This can
be done by setting to 1 bit 15 of the Watchdog Timer Mode Register, at address
\rs{hex(WDT_MR)} (see Chapter 15 in \cite{SAM3X8E}).

\section{Clock initializer}\label{section:clock-initializer}

\rust{
  const DRIVER_ADDRESS: u32 = 0xC0200;
  let mut b = BytecodeAssembler::new(RegionKind::Default, DRIVER_ADDRESS);
}

We can now use the above information to implement our clock driver, in the next
flash memory page after the interpreter, \ie, at address
\rs{hex(DRIVER_ADDRESS)}. The first goal is to provide a function to set the
clock frequency to 84MHz.\bigskip

\begin{paracol}{2}
\rs{b.func("clock_init", &[], "", &[])}

As explained in \cref{subsection:pmc-config}, this function must configure the
flash  wait time first. To be conservative, we set the $wait$ field to 6 in
both EEFC Mode Registers (\cf \cref{table:eefc-registers}). We can then
implement the 4 steps of the procedure presented in
\cref{subsection:pmc-config}.\bigskip

\bytecode[switchcolumn,bigskip]{
  b.cst(EEFC0_FMR.address);
  b.cst(0x600);
  b.store();
  b.cst(EEFC1_FMR.address);
  b.cst(0x600);
  b.store();
}

{\sffamily\bfseries Step 1} Enable the Crystal Oscillator (while leaving the RC
oscillator enabled). For this we must set $c=1$ and $r=1$ in the Main
Oscillator Register. We don't know the Crystal Oscillator start-up time and
thus set $startup$ to its maximum value, \hexa{FF}. With $password$ set to
\hexa{37}, this means that we must write \hexa{37FF09} at address
\rs{hex(PMC_MOR.address)}.

\bytecode[switchcolumn]{
  b.cst(PMC_MOR.address);
  b.cst(0x37FF09);
  b.store();
}

We then need to wait until the Crystal Oscillator is ready, \ie, until the $c$
bit in the Status Register is 1. For this we read this register, extract its
$c$ bit with a bitwise \insn{and} with \hexa{1}, and repeat these steps while
the result is 0.

\bytecode[switchcolumn,bigskip]{
  b.label("wait_crystal_ready");
  b.cst(PMC_SR.address);
  b.load();
  b.cst_1();
  b.and();
  b.cst_0();
  b.ifeq("wait_crystal_ready");
}

{\sffamily\bfseries Step 2} Select the Crystal Oscillator. For this we need to
set the same value as above in the Main Oscillator Register, with the $s$ field
additionally set to 1. That is we must write \hexa{137FF09}. We then need to
wait until the $s$ field in the Status Register is 1. This is done as above
with a bitwise \insn{and} with \hexa{10000}.

\bytecode[switchcolumn,bigskip]{
  b.cst(PMC_MOR.address);
  b.cst(0x137FF09);
  b.store();

  b.label("wait_crystal_selection");
  b.cst(PMC_SR.address);
  b.load();
  b.cst(0x10000);
  b.and();
  b.cst_0();
  b.ifeq("wait_crystal_selection");
}

{\sffamily\bfseries Step 3} Set the PPL $multiplier$ to 6 and its $divider$ to
1. We don't know the PLL start-up time and thus set $startup$ to its maximum
value, \hexa{3F}. We then wait until the Status Register's $p$ bit is 1.

\bytecode[switchcolumn,bigskip]{
  b.cst(PMC_PLLAR.address);
  b.cst(0x20063F01);
  b.store();

  b.label("wait_pll");
  b.cst(PMC_SR.address);
  b.load();
  b.cst8(2);
  b.and();
  b.cst_0();
  b.ifeq("wait_pll");
}

{\sffamily\bfseries Step 4} Select the PPL output as the Master Clock source.
For this we set $css$ to 2 in the Master Clock Register. We then wait until the
Status Register's $m$ bit is 1.

\bytecode[switchcolumn,bigskip]{
  b.cst(PMC_MCKR.address);
  b.cst8(2);
  b.store();

  b.label("wait_master_clock");
  b.cst(PMC_SR.address);
  b.load();
  b.cst8(8);
  b.and();
  b.cst_0();
  b.ifeq("wait_master_clock");
}

At this stage the Master Clock runs at 84MHz. To finish this function we can
enable the System Timer, disable the Watchdog Timer, and return.

\bytecode[switchcolumn]{
  b.cst(SYSTICK_CTRL.address);
  b.cst8(1);
  b.store();
  b.cst(WDT_MR);
  b.cst(0x8000);
  b.store();
  b.ret();
}
\end{paracol}

\section{Delay function}\label{section:delay-function}

The second goal of our clock driver is to provide a function to wait for a
calibrated amount of time. For this we can pass a number $n > 0$ of
milliseconds to wait for as an argument to this function. Which can then be
implemented by using the System Timer, as follows.\bigskip

\begin{paracol}{2}
\rs{b.func("delay", &["n"], "", &[])}

Set the System Timer reload value to 10500 times $n$ (10500 = \hexa{2904} and
$n$ is the stack frame's $0^{th}$ value).

\bytecode[switchcolumn,bigskip]{
  b.cst(SYSTICK_LOAD.address);
  b.cst(0x2904);
  b.get("n");
  b.mul();
  b.store();
}

Reset the System Timer current value.

\bytecode[switchcolumn,bigskip]{
  b.cst(SYSTICK_CURRENT.address);
  b.cst_0();
  b.store();
}

Wait until the System Timer counts from 1 to 0, \ie, until the Control and
Status Register's $z$ bit is 1.

\bytecode[switchcolumn,bigskip]{
  b.label("wait_count_zero");
  b.cst(SYSTICK_CTRL.address);
  b.load();
  b.cst(0x10000);
  b.and();
  b.cst_0();
  b.ifeq("wait_count_zero");
  b.ret();
}
\end{paracol}

Note that since the System Timer is a 24-bit counter, $n$ is limited to
$(2^{24}-1)/10500=1597$. Therefore, a single call to this function can't wait
for more than $\sim 1.5$s. By putting together the encoding of the two above
functions we get the final bytecode of our clock driver:

\rs{b.get_bytecode_listing(0..b.get_instruction_count() as usize, false)}

\rust{
  {
    let mut commands = b.boot_assistant_commands();
    commands.push(String::from("flash#"));
    write_lines("website/part2", "clock_driver.txt", &commands)?;
  }
}

Lets store it in flash memory. To avoid you some typing we provide the
necessary boot assistant commands in \verb!part2/clock_driver.txt!. Run them
with:

\rust{
  context.add_memory_region("clock_driver", b.memory_region());
  let mut flash_helper = FlashHelper::from_file(
    context.micro_controller(), "website/", "part2/clock_driver.txt")?;
}
\rs{host_log(&flash_helper.read())}

\section{Basic input output system foundations}\label{section:bios-foundations}

We now have the first elements of our basic input output system stored in flash
memory, namely an interpreter and a clock driver. In order to make the Arduino
completely autonomous, we must be able to run them automatically after a reset,
without the boot assistant. For this we need to setup a Vector Table (\cf
\cref{section:vector-table}).

\subsection{Vector Table}\label{subsection:bios-vector-table}

\rust{
  const VECTOR_TABLE: u32 = 0x80000;
  let reset_handler_address = context.memory_region("interpreter").end();
  let hard_fault_handler_address = reset_handler_address + 4 * 4;
  const STARTUP_PROGRAM: u32 = 0xC2000;

  let reset_handler =
  context.program("reset_handler").copy(reset_handler_address);
  let machine_code_blink =
    context.program("machine_code_blink").copy(hard_fault_handler_address);

  let mut vector_table = Assembler::new(VECTOR_TABLE);
  vector_table.u32_data(0x20088000, "initial stack pointer");
  vector_table.label("reset_handler");
  vector_table.u32_data(reset_handler_address | 1, "reset handler");
  vector_table.u32_data(0x0, "reserved");
  vector_table.label("hard_fault_handler");
  vector_table.u32_data(
    (hard_fault_handler_address + machine_code_blink.label_offset("start")) | 1,
    "hard fault handler");

  let mut lines = Vec::new();
  lines.extend(vector_table.boot_assistant_commands());
  let mut reset_handler_code = reset_handler.machine_code().clone();
  reset_handler_code[
    reset_handler.label_offset("bytecode handler program") as usize / 4] =
      STARTUP_PROGRAM;
  lines.extend(boot_assistant_commands(&reset_handler_code,
  reset_handler_address));
  lines.extend(machine_code_blink.boot_assistant_commands());

  let mut vector_table_region = vector_table.memory_region();
  vector_table_region.len = 4 * 4;
  context.add_memory_region("vector_table", vector_table_region);
  context.add_memory_region("reset_handler", reset_handler.memory_region());
  context.add_memory_region("hard_fault_handler",
    machine_code_blink.memory_region());
}

After a reset we want to initialize the Master Clock with the clock driver and,
later on, initialize the screen and keyboard drivers, and start the memory
editor. We can do this with a main bytecode function, called upon reset via the
Reset handler. In order to leave space for the future drivers, after the clock
driver code at \rs{hex(DRIVER_ADDRESS)}, we can put this main function at
address \rs{hex(STARTUP_PROGRAM)} (see \cref{fig:bios-memory-map}). The Reset
handler should thus call the interpreter with \rs{hex(STARTUP_PROGRAM)} as
initial Instruction Counter. We have already seen how to do that, with 2 LDR
and a BX instruction, at the end of the previous chapter. We put the
corresponding machine code

\phantom{x}\hfill {\tt \rs{hex_word(reset_handler_code[3])} %
\rs{hex_word(reset_handler_code[2])} %
\rs{hex_word(reset_handler_code[1])} %
\rs{hex_word(reset_handler_code[0])}}

\noindent at address \rs{hex(reset_handler_address)}, just after the bytecode
interpreter.

To handle potential errors, we should also define a Hard Fault handler. The
easiest solution is to make the LED blink in case of error, since we already
have a program doing this. The machine code given at the end of
\cref{subsection:blink-led-main} can then be directly reused, and put just
after the above code, \ie, at offset \rs{hex(hard_fault_handler_address)} (see
\cref{fig:bios-memory-map}).

We also need to define an initial Stack Pointer, in the Vector Table's first
entry. Since the stack grows in decreasing address order we initialize it to
the end of the contiguous RAM region, \hexa{20088000} (see
\cref{fig:boot-memory-map}).

In summary, the above choices lead to the following Vector Table (only the
first 4 entries are used; the Hard Fault handler's main function starts at
offset \hexa{14} after \rs{hex(hard_fault_handler_address)}, \ie, at
\rs{hex(hard_fault_handler_address + 0x14)}):

\rust{
  let vector_table_words = vector_table.machine_code();
  assert_eq!(vector_table_words[3], (hard_fault_handler_address + 0x14) | 1);
}
\phantom{x}\hfill {\tt \rs{hex_word(vector_table_words[3])} %
  \rs{hex_word(vector_table_words[2])} %
  \rs{hex_word(vector_table_words[1])} %
  \rs{hex_word(vector_table_words[0])}}

\begin{Figure}
  \rs{define("mmapa", &hex(context.memory_region("interpreter").start))}
  \rs{define("mmapb", &hex(reset_handler_address))}
  \rs{define("mmapc", &hex(hard_fault_handler_address))}
  \rs{define("mmapd", &hex(DRIVER_ADDRESS))}
  \rs{define("mmape", &hex(STARTUP_PROGRAM))}
  \input{figures/chapter4/bios-memory-map.tex}

  \caption{The initial layout of our basic input output system in flash memory.
  Execution starts with the Reset handler, which calls the interpreter to
  execute the Main function. This function then calls other functions, \eg, in
  the clock driver. Red, blue and gray areas represent machine code, bytecode
  and unused memory, respectively (not to scale).}\label{fig:bios-memory-map}
\end{Figure}

\subsection{Boot mode selection}\label{subsection:boot-mode-selection}

In the following we would like to test the clock driver, then implement the
screen driver and test it, then implement the keyboard driver and test it, etc.
For this we need to alternatively boot from flash (to test our system) and from
ROM (to store new drivers in flash memory with the boot assistant). However,
when the Arduino runs from flash, the only way to boot from ROM again is to do
a full erase. This means that, after each test, we would have to flash
everything again. To avoid this, as discussed at the end of
\cref{subsection:blink-led-flash}, our main function should set the boot mode
selection to boot from ROM. To this end, we provide a function doing this below.

\rust{
  let base = DRIVER_ADDRESS + 4 * ((b.bytecode_size() + 3) / 4);
  let mut c = BytecodeAssembler::new(RegionKind::Default, base);
}

\raisedhypertarget{boot-mode-select-rom}%
As explained in \cref{subsection:boot-mode}, setting the boot mode to boot from
ROM can be done by writing the value \hexa{5A00010C} in the EEFC0 Command
Register at address \rs{hex(EEFC0_FCR.address)} (and then waiting until the
Status Register is 1). After that the ROM is mapped in the ``Boot'' region,
which means that {\em our Vector Table is no longer mapped there}. In case of
error, the ROM Vector Table would thus be used instead of ours. To avoid this,
a solution is to first change the location where the Vector Table is read from,
with the Vector Table Offset Register (at address \rs{hex(SCB_VTOR)} -- see
\cref{section:vector-table}). More precisely, a solution is to store in this
register the ``real'' address of our Vector Table, \hexa{80000}. This leads to
the following bytecode function, stored just after the clock driver, at address
\rs{hex(base)} (see \cref{table:clock_driver_functions}):

\begin{TwoColumns}
\bytecode{
  c.func("boot_mode_select_rom", &[], "", &[]);
  c.cst(SCB_VTOR);
  c.cst(0x80000);
  c.store();
  c.cst(EEFC0_FCR.address);
  c.cst(0x5A00010C);
  c.store();
  c.label("wait_ready");
  c.cst(EEFC0_FSR.address);
  c.load();
  c.cst_1();
  c.ifne("wait_ready");
  c.ret();
  context.add_memory_region("foundations", c.memory_region());
}
\end{TwoColumns}

\rust{
  lines.extend(c.boot_assistant_commands());
  lines.push(String::from("flash#"));
  write_lines("website/part2", "foundations.txt", &lines)?;
  let mut flash_helper = FlashHelper::from_file(
    context.micro_controller(), "website/","part2/foundations.txt")?;
}

To avoid you some typing, we provide the boot assistant commands necessary to
write this function, the above Vector Table, and its Reset and Hard Fault
handlers in flash memory. Run them with:

\rs{host_log(&flash_helper.read())}

\section{Experiments}\label{section:clock-driver-experiments}

In order to test the above functions we can implement a third version of our
LED blinking program where:
\begin{itemize}
  \item calls to the boot mode selection and clock initializer functions are
  added at the beginning,

  \item calls to the waiting function are replaced with calls to the delay
  function (and the waiting function is deleted).
\end{itemize}

\rust{
  let table_rows = MemoryRegion::labels_table_rows(
      vec![&b.memory_region(), &c.memory_region()]);
}

\begin{Table}
  \begin{tabular}{|l|l|} \hline
    \makecell{\thead{Function}} & \thead{Address} \\ \hline
    \rs{table_rows} \\ \hline
  \end{tabular}

  \caption{The basic input output system functions defined in this
    chapter.}\label{table:clock_driver_functions}
\end{Table}

\noindent And to use it as a main function we can put it in flash memory at
address \rs{hex(STARTUP_PROGRAM)}. With $500 \mathrm{ms}$ delays, we get the
following function, based on the version in \cref{section:blink-led-bytecode}
($\rs{dec_hex(500u32)}$):

\begin{TwoColumns}
\bytecode{
  let mut t = BytecodeAssembler::new(RegionKind::Default, STARTUP_PROGRAM);
  t.import_labels(context.memory_region("clock_driver"));
  t.import_labels(context.memory_region("foundations"));
  t.func("main", &[], "", &[]);
  t.call("boot_mode_select_rom");
  t.call("clock_init");
  t.cst(PIOB_PER);
  t.cst(1 << 27);
  t.store();
  t.cst(PIOB_OER);
  t.cst(1 << 27);
  t.store();
  t.cst(PIOB_PUDR);
  t.cst(1 << 27);
  t.store();
  t.label("main_loop");
  t.cst(PIOB_SODR);
  t.cst(1 << 27);
  t.store();
  t.cst(500);
  t.call("delay");
  t.cst(PIOB_CODR);
  t.cst(1 << 27);
  t.store();
  t.cst(500);
  t.call("delay");
  t.goto("main_loop");
}
\end{TwoColumns}

Write it in flash memory with:

\rust{
  let mut lines = Vec::new();
  lines.extend(t.boot_assistant_commands());
  lines.push(String::from("flash#"));
  write_lines("website/part2", "clock_driver_test.txt", &lines)?;
  let mut flash_helper = FlashHelper::from_file(
  context.micro_controller(), "website/","part2/clock_driver_test.txt")?;
}
\rs{host_log(&flash_helper.read())}

To run it we need to change the boot mode selection to boot from flash, and to
reset the Arduino. The former can be done by writing \hexa{5A00010B} at address
\rs{hex(EEFC0_FCR.address)} (\cf \cref{subsection:boot-mode}). And the latter
with the RESET button or, with the Reset Controller (see \cref{fig:sam3x8e}),
by writing \hexa{A500000D} at address \rs{hex(RSTC_CR)} (see Section 12.5.1 in
\cite{SAM3X8E}). For convenience, \verb!flash_helper.py! provides a
\verb!reset#! command doing these two steps. We can thus run our program with:

\rust{
  let mut flash_helper = FlashHelper::new(context.micro_controller());
  flash_helper.write("reset#");
}
\rs{host_log(&flash_helper.read())}

\rust{
  let blink_counter = Rc::new(RefCell::new(BlinkLedCounter::default()));
  let micro_controller = context.micro_controller();
  micro_controller.borrow_mut().set_pio_device(blink_counter.clone());

  context.micro_controller().borrow_mut().run(100000);
  assert!(blink_counter.borrow().blink_count >= 10);
}

At this point you should see the LED blinking once per second\footnote{Almost:
each cycle lasts 1s plus a few $\mu s$ due to the instructions between the
delay function calls.}, without begin reset by the Watchdog timer. Then press
the RESET button on the Arduino: the LED should no longer blink, because the
Arduino booted from ROM. Finally, lets test our Hard Fault handler by
introducing a voluntary error in our LED blinking program. We can do this by
replacing the last \insn{goto} insn with an invalid \hexa{FF} opcode:

\rust{
  context.micro_controller().borrow_mut().reset();
  let mut flash_helper = FlashHelper::new(context.micro_controller());
  assert_eq!(t.bytecode_words()[19], 0x12028B1A);
  flash_helper.write(&format!("W{:X},{:X}#",
    STARTUP_PROGRAM + 19*4, 0x12028B1A | 0xFF000000u32));
  flash_helper.write("flash#");
  flash_helper.write("reset#");
}
\rs{host_log(&flash_helper.read())}

You should see the LED blinking once as before (as the beginning of the program
executes normally), then blink very fast. Indeed, when the unknown opcode is
found, the interpreter triggers an Undefined Instruction exception, which
triggers the Hard Fault handler. This calls our machine code LED blinking
function, which counts to 1 million between each step. At 84MHz, this yields
very fast blinks. You can finally reset and unplug the Arduino.

\rust{
  let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
    context.micro_controller().borrow_mut().run(20000);
  }));
  assert!(result.is_err());
  context.micro_controller().borrow_mut().reset();
}
