% This work is licensed under the Creative Commons Attribution NonCommercial
% ShareAlike 4.0 International License. To view a copy of the license, visit
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\renewcommand{\rustfile}{chapter4}
\setcounter{rustid}{0}

\rust{
  context.write_backup("website/backups", "streams.txt")?;
}

\chapter{Streams}\label{chapter:streams}

Our kernel can now spawn an initial process, which can itself spawn other
processes. However, these processes can't use the keyboard, the screen, or the
disk unless they re-implement the related kernel functions. Indeed, for the
reasons explained in the previous chapter, they can't call these functions
directly. This chapter extends our kernel with new system calls in order to
solve this problem.

\section{Requirements}

The new system calls should provide access to all existing kernel services.
This includes the delay and boot mode selection services, getting the last
character typed or waiting for one, displaying text on screen, and listing,
creating, reading, writing, and deleting files. We also require a new service:
the possibility for a process to return more data to its parent than a single
exit value (other than via files).

These system calls should encapsulate the kernel's implementation details, so
that it can be improved without having to rewrite user programs, also called
applications. For instance, users must not have to deal with {\tt DiskBlock} or
{\tt FileBlock}, so that these data structures can be replaced with better ones
later on.

The new system calls must also provide a safe way to use the computer
resources, and the disk in particular. This is not the case of the current file
system functions. For instance, it is possible to inadvertently pass a free
block to a function expecting a file block, which might cause a crash or
corrupt the file system. This could happen, for example, if a process gets the
first block of a file, spawns a child process which happens to delete the file,
and then uses this block to read the file after the child terminates.

\section{Design}

In order to meet the above requirements we use a design inspired from the one
used in many existing operating systems for this purpose. More precisely, we
model the keyboard, the graphics card, and the files as sources and/or sinks of
bytes, transmitted one after the other:
\begin{itemize}
  \item the keyboard is a source of bytes, one per character typed.

  \item the graphics card is a sink of commands, sent to it to write values in
  its registers, and a source of values, read from its registers (see
  \cref{subsection:gpu-protocol}).

  \item a file is a source of bytes when it is read, and a sink of bytes when
  new data is appended to it.
\end{itemize}

These sources and sinks are called {\em input streams} and {\em output
streams}, respectively. We introduce two new system calls, called {\tt read}
and {\tt write}, to read bytes from an input stream, and to write bytes in an
output stream, respectively. We then define the following streams, identified
with a {\em stream ID}:
\begin{itemize}
  \item STANDARD\_INPUT (ID 0): the stream of characters typed on the keyboard.
  Reading a byte from this stream returns the last character typed since the
  last one read. If there is none this operation {\em blocks}, \ie, waits until
  a character is typed.

  \item STANDARD\_OUTPUT (ID 1): a stream of bytes sent by a process to its
  parent. These bytes are appended to a buffer provided by the parent. They
  allow processes to return more data to their parent than a single exit value.

  \item KEYBOARD (ID 2): a {\em non-blocking} stream of the characters typed on
  the keyboard. Reading a byte from this stream returns the last character
  typed (since the last one read from STANDARD\_INPUT or KEYBOARD), or 0 if
  there is none.

  \item GPU (ID 3): an input and output stream used to send commands to the
  graphics card, and to read the value of its registers.
\end{itemize}

File streams can not have a fixed stream ID, since files can be created and
deleted at any time. Instead, we define two more system calls to create a
stream for a given file, and to delete a file stream. They are called {\tt
open} and {\tt close}, respectively:
\begin{itemize}
  \item {\tt open} takes as parameter a file name and a {\em mode} (read or
  write). It creates either an input stream or an output stream, depending on
  the mode, and returns the ID of this new stream. Creating an output stream
  either creates a file if there is no file with the given name, or {\em
  clears} the existing file content.

  \item {\tt close} takes as parameter a file stream ID and deletes this stream.
\end{itemize}

Several input streams can exist at a given time for a single file. Each input
stream has its own {\em cursor}, which indicates how many bytes have already
been read from the file. Thus, for instance, one stream could have already read
10 bytes of a file, while another could have read 20 bytes of the same file.

To simplify, and to ensure safety at the same time, we do not allow the
coexistence of several output streams for the same file (across all processes).
We do not allow either the coexistence of input and output streams for a given
file. Similarly, we forbid the deletion of a file (for which we add a {\tt
delete} system call) which has some associated input or output streams (in any
process).

\section{Data structures and algorithms}

\subsection{STANDARD\_INPUT}

Reading a byte from standard input is easy to do with the {\tt
keyboard\_wait\_char} function. Note however that this function must be called
from the SVC handler in order to use it in the {\tt read} system call. In other
words, it must run as part of the SVC interrupt handler. But it might itself
wait for the USART handler to run, to get characters from the keyboard. For
this to work, an USART interrupt must be able to interrupt the SVC handler.
Otherwise the latter would wait forever. However, by default, an interrupt
handler cannot interrupt another.

To handle such cases the ARM Cortex M3 uses {\em interrupt priorities}.
Interrupts with higher priority are executed first, and can interrupt a
currently running handler with a lower priority. Each type of interrupt has a
configurable priority, specified with a so-called {\em priority level} (a
non-negative integer). By default, all interrupt types have priority level 0,
which corresponds to the highest priority\footnote{Reset and Hard Fault have
even higher, non-configurable priorities.}. Increasing the priority level of an
interrupt decreases its priority.

To solve the above problem we thus need to increase the priority level of SVC
interrupts, \ie, to decrease their priority (we cannot increase the USART
priority since it is already the highest possible). This can be done with the
SVC Handler Priority Register, at address \hexa{E000ED1C} in the ``System''
region (see \cref{fig:boot-memory-map}). The most significant byte of this
register defines the priority level of SVC interrupts (the other bytes are
``reserved'').

\subsection{STANDARD\_OUTPUT}

In order to write data to standard output, on behalf of a process, the kernel
must have a pointer to an output buffer provided by the parent, as well as its
capacity. To this end:

\begin{itemize}
  \item we add a new {\tt output\_p} parameter to the {\tt spawn} system call.
  This parameter must be a pointer to a word containing the buffer's start
  address (see \cref{fig:stdout}).

  \item we use the existing spawn's {\tt dst} parameter as the buffer's
  limit address.
\end{itemize}

Each time the kernel appends a byte to this buffer, it also increases the
address at {\tt output\_p}. This allows a parent process to compute how many
bytes were written by its child, once it terminates (see \cref{fig:stdout}).

\begin{Figure}
  \input{figures/chapter4/stdout.tex}

  \caption{A child process writes STANDARD\_OUTPUT data at the address stored
  in the word at {\tt output\_p}, up to {\tt dst}, and updates this address
  (top). When it terminates (bottom), the word at {\tt output\_p} points to the
  end of the data it wrote (brown). Red, yellow, green, and gray areas
  represent native code, heap, stack, and unused memory,
  respectively.}\label{fig:stdout}
\end{Figure}

\subsection{GPU}

The GPU stream is used to read and write the value of the graphics card
registers. Recall that this is done with 3 types of commands, each using 2
bytes: Select Register, Read Data, and Write Data
(\cref{subsection:gpu-protocol}). We thus use the following algorithms:
\begin{itemize}
  \item reading a byte from GPU sends a Read Data command to the graphics card
  and returns the result. This gives the value of the last register selected
  with a Select Register command.

  \item writing two bytes in GPU sends the corresponding command to the
  graphics card. This must be either a Select Register or a Write Data command.
  Some registers are sensitive and might damage the card if not used correctly,
  such as those setting the clock frequency. For safety, we filter out the
  Select Register commands for these registers.
\end{itemize}

\subsection{File streams}\label{subsection:file-streams}

A process can create several file streams with {\tt open}. Each has its own ID,
mode (read or write), and cursor. To keep track of this information we add a
{\tt file\_streams} field in the {\tt Process} struct, pointing to a linked
list of {\tt FileStream} data structures. Each {\tt FileStream} contains the
following data (see \cref{fig:streams-data-structures}):
\begin{itemize}
  \item a pointer to the next {\tt FileStream} in the list, or {\tt null} for
  the last one.

  \item the stream's mode. We use 'r' for the read mode, and 'w' for the
  write mode.

  \item a pointer to the {\tt FileBlock} of the file from which this stream was
  created.

  \item the stream's cursor, pointing to the next byte to read from or to write
  to this file. It is represented with a pointer to a {\tt DiskBlock}, and an
  offset within this block:
  \begin{itemize}
    \item for an input stream, the offset is the number of bytes that have
    already been read in this block, plus the block's header size.

    \item for an output stream the offset is unused. Instead, bytes are
    appended after the last used one in the block, which is specified in the
    block's header.
  \end{itemize}
\end{itemize}

Note that a {\tt FileStream} does not store its ID. Instead, we use its
position in the {\tt file\_streams} list to compute its ID: the $i^{th}$
element, counting from 0, has ID $i+4$\footnote{Stream IDs are local: two
streams with the same ID, in different processes, can refer to different
files.}. A consequence is that, when a file stream is closed, it cannot be
deleted and removed from the {\tt file\_streams} list (this would change the
IDs of the next streams). Instead, we set its mode to 0, meaning ``unused'',
and its {\tt FileBlock} pointer to {\tt null}.

We store the newly created {\tt FileStream} data structures after the current
{\tt Process}, in the kernel's heap. They are automatically deleted when the
process terminates. This is because a {\tt Process} is deleted, in {\tt
os\_exit}, by restoring the kernel's {\tt heap} pointer to the value it had
just before the process was created.

\subsubsection{Files list}

In order to get a list of all the files we use a virtual {\em directory}
containing this list of names. By convention, users can {\tt open} it in read
mode by using an empty file name. This gives a stream from which file names can
be read one by one (in their entirety; to simplify, we do not allow reading a
file name piece by piece).

To implement this we represent a directory stream with a {\tt FileStream}
whose mode is 'l' (for ``list''). The {\tt FileBlock} pointer of such a stream
points to the file whose name must be returned by the next {\tt read} call. Its
cursor is unused ({\tt DiskBlock} pointer and offset).

Although we forbid deleting a file with at least one open stream, we do not
forbid deleting one which is the next to be returned by a directory stream.
Instead, if a directory stream points to a file which is about to be deleted,
we advance it to the next file.

\begin{Figure}
  \input{figures/chapter4/data-structures.tex}

  \caption{A process has a linked list of structs representing its file streams
  (red links). Each stream points to the corresponding file block (bottom) and
  to the next byte to read or write. Here the first stream, with implicit ID 4,
  has read the first block and $7-4=3$ bytes of the second block of the ``Cat''
  file.}\label{fig:streams-data-structures}
\end{Figure}

\section{Implementation}

We can now extend the second version of our kernel, written in the previous
chapter, with the algorithms described above. The first change is the addition
of the {\tt load16} function, copied from our native compiler. We use it later
on to read commands from the GPU stream:

\rust{
  let mut t = Transpiler5::new_str(
      &context.get_text(context.memory_region("kernel_source").start));
  t.add_unchanged(
      "fn os_init(code: &u32, heap: &u32, stack: &u32);", "fn load8(");
}

\toy{
@fn load8(ptr: &u32) -> u32 [ /*LDRB_R0_R0_0*/30720; /*MOV_PC_LR*/18167; ]
fn load16(ptr: &u32) -> u32 [ /*LDRH_R0_R0_0*/34816; /*MOV_PC_LR*/18167; ]
}%toy

\rust{
  t.add_unchanged("fn store8(", "struct Process");
}

The following existing code is unchanged, up to and including the {\tt Context}
struct. We implement the {\tt FileStream} struct just after it, as described
above. We also add new fields in {\tt Process} to store its list of file
streams, as well as its {\tt output\_p} parameter. The {\tt output\_limit}
field indicates the limit of the standard output buffer.

\toy{
const MODE_UNUSED: u32 = 0;
const MODE_LIST: u32 = 'l';
const MODE_READ: u32 = 'r';
const MODE_WRITE: u32 = 'w';

struct FileStream {
  next: &FileStream,
  mode: u32,
  file_block: &FileBlock,
  current_block: &DiskBlock,
  current_offset: u32
}
@struct Process {
@  parent: &Process,
@  begin: &u32,
@  end: &u32,
  saved_context: &Context,
  file_streams: &FileStream,
  output_p: &&u32,
  output_limit: &u32
}
}%toy

We continue by removing the temporary {\tt draw\_char} field in {\tt Kernel},
and by replacing it with fields for the new system calls, implemented below. We
also add a small utility function computing the minimum of two numbers, needed
later on.

\rust{
  t.add_unchanged("struct Kernel", "\tspawn: u32,");
}
\toy{
@  spawn: u32,
@  exit: u32,
  sleep: u32,
  stat: u32,
  open: u32,
  read: u32,
  write: u32,
  close: u32,
  delete: u32,
  reboot: u32
\}

@const KERNEL_POINTER_REGISTER: &&Kernel = 1074666140;
@fn os_kernel() -> &Kernel { return *KERNEL_POINTER_REGISTER; }

fn min(x: u32, y: u32) -> u32 {
  if x < y { return x; } else { return y; }
}
}%toy

\rust{
  t.add_unchanged("fn get_process_stack_pointer(", "fn os_spawn(");
}

The {\tt os\_spawn} function must be updated to take the new {\tt output\_p}
parameter into account. This requires additional validations, to make sure that
the 4 bytes starting at {\tt output\_p} are contained in the parent's memory
region. We must also check that the address stored at {\tt output\_p} is in
this region, and before {\tt dst}. After that we can simply store {\tt
output\_p} and the output buffer limit address ({\tt dst}) in the process
struct.

\toy{
fn os_spawn(dst: &u32, name: &u32, name_length: u32,
    args: &u32, args_length: u32, output_p: &&u32) -> u32 {
...@  let kernel = os_kernel();
...@  if sizeof(Process) > kernel.heap_limit - kernel.heap {
...@    return error_result(OUT_OF_MEMORY);
...@  }
...@  let begin = (((dst as u32 + 31) >> 5) << 5) as &u32;
...@  let end = (((kernel.stack_limit as u32) >> 5) << 5) as &u32;
...@  let parent = kernel.current_process;
@  if parent != null {
...@    end = ((get_process_stack_pointer() as u32 >> 5) << 5) as &u32;
...@    if end < begin || begin < parent.begin ||
...@        process_contains_buffer(parent, name, name_length) == FALSE ||
...@        process_contains_buffer(parent, args, args_length) == FALSE {
...@      return error_result(INVALID_ARGUMENT);
...@    }
@    if args + args_length > begin && args < end {
@      return error_result(INVALID_ARGUMENT);
@    }
    if process_contains_buffer(parent, output_p as &u32, 4) == FALSE ||
        *output_p < parent.begin || *output_p > dst {
      return error_result(INVALID_ARGUMENT);
    }
@  }
...@  let file_block = disk_find_file(name, name_length, null);
...@  if file_block == null { return error_result(NOT_FOUND); }
...@  let code_size = disk_get_file_size(file_block);
...@  if code_size > end - begin {
...@    return error_result(OUT_OF_MEMORY);
...@  }
...@  const MIN_STACK_SIZE: u32 = 512;
...@  let heap = begin + code_size;
...@  let heap_limit = end - MIN_STACK_SIZE;
...@  if heap_limit < heap + 4 || args_length > heap_limit - heap - 4 {
...@    return error_result(OUT_OF_MEMORY);
...@  }
...@  let offset = 12 + name_length;
...@  disk_read_file(&file_block as &&DiskBlock, &offset, begin, code_size);
...@  *heap = args_length;
...@  mem_copy_non_overlapping(args, heap + 4, args_length);
...@  let context = (end - sizeof(Context)) as &Context;
...@  context.r0 = heap as u32;
...@  context.r1 = heap_limit as u32;
...@  context.r14 = 0;
...@  context.return_address = begin as u32;
...@  context.status_register = 1 << 24;
...@  if parent != null {
...@    parent.saved_context = get_process_stack_pointer() as &Context;
...@  }
...@  let process = kernel.heap as &Process;
...@  kernel.heap = kernel.heap + sizeof(Process);
...@  process.parent = parent;
...@  process.begin = begin;
...@  process.end = end;
@  process.saved_context = context;
  process.file_streams = null;
  process.output_p = output_p;
  process.output_limit = dst;
@  os_set_current_process(kernel, process);
@  return OK;
@}
}%toy

We keep the {\tt os\_exit} function unchanged since it already automatically
deletes the process's file streams. On the other hand we delete the temporary
{\tt os\_draw\_char} function, and start implementing functions for the new
system calls. The first one provides access to the {\tt delay} function. Since
this function is restricted to delays of about $1.5s$ (see
\cref{section:delay-function}) we call it several times if needed:

\rust{
  t.add_unchanged("fn os_exit(", "fn os_draw_char(");
}
\toy{
fn os_sleep(millis: u32) -> u32 {
  while millis > 1000 { delay(1000); millis = millis - 1000; }
  delay(millis);
  return OK;
}
}%toy

With the stream system calls presented above it is not possible to get the size
of a file other than by reading it completely. To improve this we provide the
following system call, which returns the size of the specified file. If the
given name is not contained in the process's memory region, or if the file is
not found, it returns an error instead (in the most significant byte, see
\cref{subsection:status_or}):

\toy{
fn os_stat(name: &u32, length: u32) -> u32 {
  let process = os_kernel().current_process;
  if process_contains_buffer(process, name, length) == FALSE {
    return error_result(INVALID_ARGUMENT);
  }
  let file_block = disk_find_file(name, length, null);
  if file_block == null { return error_result(NOT_FOUND); }
  return disk_get_file_size(file_block);
}
}%toy

Before implementing the stream system calls it is useful to have some functions
to manage the file streams of a process. The following one returns the {\tt
FileStream} with the given ID, or {\tt null} if there is none:

\toy{
const STANDARD_INPUT: u32 = 0;
const STANDARD_OUTPUT: u32 = 1;
const KEYBOARD: u32 = 2;
const GPU: u32 = 3;
const FIRST_FILE_STREAM_ID: u32 = 4;

fn process_get_file_stream(self: &Process, stream_id: u32) -> &FileStream {
  let stream = self.file_streams;
  let id = FIRST_FILE_STREAM_ID;
  while stream != null && id != stream_id {
    stream = stream.next;
    id = id + 1;
  }
  return stream;
}
}%toy

The next function returns the first unused {\tt FileStream} of a process, or
creates one if all streams are used. In the latter case, it adds the {\tt
FileStream} at the end of the {\tt file\_streams} list, in order to avoid
changing the implicit ID of the existing ones. This requires updating the {\tt
next} field of the last existing {\tt FileStream}, or the process's {\tt
file\_streams} field if there is no existing stream. The {\tt stream\_ptr}
variable points to the former or to the later, depending on which case applies.

This function stores the ID of the returned stream at address {\tt stream\_id}.
It returns {\tt null} if there is not enough memory in the kernel's heap to
create a {\tt FileStream}.

\toy{
fn process_get_unused_file_stream(self: &Process, stream_id: &u32) \
-> &FileStream {
  let stream_ptr = &self.file_streams;
  let stream = *stream_ptr;
  *stream_id = FIRST_FILE_STREAM_ID;
  while stream != null && stream.mode != MODE_UNUSED {
    stream_ptr = &stream.next;
    stream = *stream_ptr;
    *stream_id = *stream_id + 1;
  }
  let kernel = os_kernel();
  if stream == null && kernel.heap + sizeof(FileStream) <= kernel.heap_limit {
    stream = kernel.heap as &FileStream;
    kernel.heap = kernel.heap + sizeof(FileStream);
    stream.next = null;
    stream.mode = MODE_UNUSED;
    stream.file_block = null;
    *stream_ptr = stream;
  }
  return stream;
}
}%toy

Another convenient function is the following, which checks if a given file can
be opened in read or write mode. For this it checks all the file streams of all
the processes. If one of them corresponds to {\tt file\_block}, in read or
write mode, then the file can only be opened again in read mode, provided it is
not already open in write mode.

\toy{
fn process_can_open(self: &Process, file_block: &FileBlock, mode: u32) -> u32 {
  let process = self;
  let stream: &FileStream = null;
  while process != null {
    stream = process.file_streams;
    while stream != null {
      if stream.file_block == file_block && stream.mode != MODE_LIST {
        if stream.mode == MODE_WRITE || mode == MODE_WRITE {
          return FALSE;
        }
      }
      stream = stream.next;
    }
    process = process.parent;
  }
  return TRUE;
}
}%toy

We can now implement the stream system call functions themselves, starting with
{\tt open}. This function takes a file name and a mode as parameters, and
returns a stream ID or an error. It first validates its arguments, and gets or
creates an unused {\tt FileStream} and its ID. An empty file name designates
the virtual directory, which can only be read (with the internal ``list''
mode). Otherwise, in read mode, the file must exists. In write mode it is
created if it does not exist yet. It is cleared otherwise.

\toy{
fn os_open(name: &u32, length: u32, mode: u32) -> u32 {
  let process = os_kernel().current_process;
  if process_contains_buffer(process, name, length) == FALSE ||
      mode != MODE_READ && mode != MODE_WRITE {
    return error_result(INVALID_ARGUMENT);
  }
  let stream_id = 0;
  let stream = process_get_unused_file_stream(process, &stream_id);
  if stream == null { return error_result(OUT_OF_MEMORY); }
  let file_block = SUPER_BLOCK.first_file;
  let status = OK;
  if length == 0 {
    if mode != MODE_READ { status = INVALID_ARGUMENT; }
    mode = MODE_LIST;
  } else {
    file_block = disk_find_file(name, length, null);
    if file_block == null {
      if mode == MODE_READ {
        status = NOT_FOUND;
      } else {
        status = disk_create_file(name, length, &file_block);
      }
    } else if process_can_open(process, file_block, mode) == TRUE {
      if mode == MODE_READ {
        stream.current_offset = 12 + file_block.name_length;
      } else {
        disk_clear_file(file_block);
      }
    } else {
      status = INVALID_STATE;
    }
  }
  if status != OK { return error_result(status); }
  stream.mode = mode;
  stream.file_block = file_block;
  stream.current_block = file_block as &DiskBlock;
  return stream_id;
}
}%toy

The next function reads up to {\tt size} bytes from the given stream, into {\tt
buffer}. It returns the number of bytes actually read, or an error. For this it
first checks its arguments. Then, if the stream is STANDARD\_INPUT or KEYBOARD,
it reads only one character, in a blocking or non-blocking way. If the stream
is GPU it reads exactly {\tt size} bytes by sending as many Read Data commands.
If it is STANDARD\_OUTPUT this is an error. Any other case corresponds to a
file stream or a directory stream. In the latter case, this function copies up
to {\tt size} bytes of the current file name, and advances the stream to the
next file. To avoid getting truncated file names, users must pass a buffer
which can contain the longest possible file name, \ie, 244 characters.

\toy{
fn os_read(stream_id: u32, buffer: &u32, size: u32) -> u32 {
  let process = os_kernel().current_process;
  if size == 0 || process_contains_buffer(process, buffer, size) == FALSE {
    return error_result(INVALID_ARGUMENT);
  }
  let i = 0;
  if stream_id < FIRST_FILE_STREAM_ID {
    if stream_id == STANDARD_INPUT {
      *buffer = keyboard_wait_char();
      return 1;
    } else if stream_id == KEYBOARD {
      *buffer = keyboard_get_char();
      return 1;
    } else if stream_id == GPU {
      while i < size {
        store8(buffer + i, spi_transfer(16384 /*Read Data Command*/));
        i = i + 1;
      }
      return size;
    } else {
      return error_result(INVALID_STATE);
    }
  }
  let stream = process_get_file_stream(process, stream_id);
  if stream == null || stream.mode == MODE_UNUSED {
    return error_result(NOT_FOUND);
  }
  if stream.mode == MODE_LIST {
    if stream.file_block == null { return 0; }
    size = min(size, stream.file_block.name_length);
    mem_copy_non_overlapping(&stream.file_block.name, buffer, size);
    stream.file_block = stream.file_block.next_file;
    return size;
  }
  if stream.mode != MODE_READ { return error_result(INVALID_STATE); }
  return size - disk_read_file(&stream.current_block, \
&stream.current_offset, buffer, size);
}
}%toy

Before implementing a function for the {\tt write} system call we need one to
validate a command before sending it to the GPU. This helper function must
filter out invalid commands (only Select Register and Write Data can be used)
as well as Select Register commands for ``sensitive'' registers. For this we
define a list of ``safe'' registers:

\toy{
static GPU_SAFE_REGISTERS = [
  4, 0, 1, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0,
  255, 224, 255, 255, 255, 31, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
}%toy

These 32 bytes contain 256 bits, one per possible GPU register. The $i^{th}$
bit, counting from 0, is 1 if register R$i$ is judged ``safe'', or 0 otherwise
(such as registers setting clock frequencies -- see the full register list in
\cite{RA8875}). The following function uses it to filter out invalid GPU
commands as described above (the $i^{th}$ bit is the $j^{th}$ bit of the
$k^{th}$ byte, where $j=i\bmod 8=i\wedge7$ and $k=i/8=i\gg 3$):

\toy{
fn os_gpu_write(value: u32) {
  let command = value >> 8;
  let register = value & 255;
  let mask = 0;
  if command != 0 /*Write Data Command*/ {
    if command != 128 /*Select Register Command*/ { return; }
    mask = 1 << (register & 7);
    if *(GPU_SAFE_REGISTERS + (register >> 3)) & mask == 0 { return; }
  }
  spi_transfer(value);
}
}%toy

The next function writes up to {\tt size} bytes from the given {\tt buffer},
into the given stream. It returns the number of bytes actually written, or an
error. If the arguments are valid, and if the stream is STANDARD\_OUTPUT, it
copies as many bytes as possible into the process's output buffer (given its
remaining capacity). If the stream is GPU, it sends these bytes to the graphics
card two by two, with the above function (if {\tt size} is odd the last byte is
not sent). Otherwise the stream must be a file stream in write mode. In this
case this function appends the whole buffer to the corresponding file (this can
fail if the disk is full).

\toy{
fn os_write(stream_id: u32, buffer: &u32, size: u32) -> u32 {
  let process = os_kernel().current_process;
  if process_contains_buffer(process, buffer, size) == FALSE {
    return error_result(INVALID_ARGUMENT);
  }
  let i = 0;
  if stream_id < FIRST_FILE_STREAM_ID {
    if stream_id == STANDARD_OUTPUT {
      size = min(size, process.output_limit - *process.output_p);
      mem_copy_non_overlapping(buffer, *process.output_p, size);
      *process.output_p = *process.output_p + size;
      return size;
    } else if stream_id == GPU {
      while i + 1 < size {
        os_gpu_write(load16(buffer + i));
        i = i + 2;
      }
      return i;
    } else {
      return error_result(INVALID_STATE);
    }
  }
  let stream = process_get_file_stream(process, stream_id);
  if stream == null || stream.mode == MODE_UNUSED {
    return error_result(NOT_FOUND);
  }
  if stream.mode != MODE_WRITE { return error_result(INVALID_STATE); }
  let status = disk_write_file(&stream.current_block, buffer, size);
  if status != OK { return error_result(status); }
  return size;
}
}%toy

Closing a file stream is very easy (see \cref{subsection:file-streams}):

\toy{
fn os_close(stream_id: u32) -> u32 {
  let process = os_kernel().current_process;
  let stream = process_get_file_stream(process, stream_id);
  if stream == null || stream.mode == MODE_UNUSED {
    return error_result(NOT_FOUND);
  }
  stream.mode = MODE_UNUSED;
  stream.file_block = null;
  return OK;
}
}%toy

The following function deletes the file with the given name. Before this it
checks that its arguments are valid, that the file exists and that no process
is currently reading it or writing to it (by checking that it could be open in
write mode). It also advances all the directory streams which reference it to
the next file (by iterating over all file streams of all processes):

\toy{
fn os_delete(name: &u32, length: u32) -> u32 {
  let process = os_kernel().current_process;
  if process_contains_buffer(process, name, length) == FALSE {
    return error_result(INVALID_ARGUMENT);
  }
  let previous_file_block: &FileBlock = null;
  let file_block = disk_find_file(name, length, &previous_file_block);
  if file_block == null { return error_result(NOT_FOUND); }
  if process_can_open(process, file_block, MODE_WRITE) == FALSE {
    return error_result(INVALID_STATE);
  }
  let stream: &FileStream = null;
  while process != null {
    stream = process.file_streams;
    while stream != null {
      if stream.mode == MODE_LIST && stream.file_block == file_block {
        stream.file_block = file_block.next_file;
      }
      stream = stream.next;
    }
    process = process.parent;
  }
  disk_delete_file(file_block, previous_file_block);
  return OK;
}
}%toy

The last new system call function reboots the computer and launches the
operating system (if {\tt mode} is not 1) or the Boot Assistant (if {\tt mode}
is 1). For this it changes the boot mode to boot from ROM if necessary, and
then triggers a reset with the Reset Control Register, at address
\rs{hex_dec(0x400E1A00u32)} (see \cref{section:clock-driver-experiments}):

\toy{
fn os_reboot(mode: u32) -> u32 {
  const RESET_CONTROL_REGISTER: &u32 = 1074665984;
  const RESET_COMMAND: u32 = 2768240653;
  if mode == 1 { boot_mode_select_rom(); }
  *RESET_CONTROL_REGISTER = RESET_COMMAND;
  return OK;
}
}%toy

\rust{
  t.add_unchanged("fn hard_fault_handler(", "const NUM_SYSTEM_CALLS:");
}

After that the existing kernel code is mostly unchanged. The SVC handler, in
particular, does not need to be updated to take the new system call functions
into account. Instead, we just need to update the constants describing the
number of system calls and the arity of each one (in the order they are
declared in {\tt Kernel}):

\toy{
const NUM_SYSTEM_CALLS: u32 = 10;
static SYSTEM_CALL_ARITY = [6, 1, 1, 2, 3, 3, 3, 1, 2, 1];
}%toy

\rust{
  t.add_unchanged("struct CallArguments", "fn os_init(");
}

The {\tt os\_init} function just needs to be updated in order to store the new
system call function addresses in the {\tt kernel} struct, and to configure the
SVC handler priority level. Here we use the maximum priority level (255), \ie,
the lowest possible priority.

\toy{
@fn os_init(code: &u32, heap: &u32, stack: &u32) {
...@  const VECTOR_TABLE_OFFSET_REGISTER: &&u32 = 3758157064;
...@  const HARD_FAULT_HANDLER_OFFSET: u32 = 12;
...@  const SVC_HANDLER_OFFSET: u32 = 44;
...@  const USART_HANDLER_OFFSET: u32 = 132;
...@  let vector_table = code - 257;
...@  *(vector_table + HARD_FAULT_HANDLER_OFFSET) = hard_fault_handler + 1;
...@  *(vector_table + SVC_HANDLER_OFFSET) = supervisor_call_handler + 1;
...@  *(vector_table + USART_HANDLER_OFFSET) = usart_handler + 1;
...@  *VECTOR_TABLE_OFFSET_REGISTER = vector_table;
...@
...@  restore_bios_vector_table();
...@
...@  const MAX_KERNEL_HEAP_SIZE: u32 = 512;
...@  const MAX_KERNEL_STACK_SIZE: u32 = 512;
...@  let kernel = heap as &Kernel;
...@  kernel.heap = heap + sizeof(Kernel);
...@  kernel.heap_limit = heap + MAX_KERNEL_HEAP_SIZE;
...@  kernel.stack_limit = stack - MAX_KERNEL_STACK_SIZE;
...@  kernel.current_process = null;
...@  kernel.spawn = os_spawn;
@  kernel.exit = os_exit;
  kernel.sleep = os_sleep;
  kernel.stat = os_stat;
  kernel.open = os_open;
  kernel.read = os_read;
  kernel.write = os_write;
  kernel.close = os_close;
  kernel.delete = os_delete;
  kernel.reboot = os_reboot;
@  *(KERNEL_POINTER_REGISTER as &&Kernel) = kernel;

@  clock_init();
@  keyboard_init();
@  gpu_init();
  const SVC_HANDLER_PRIORITY_REGISTER: &u32 = 3758157084;
  *SVC_HANDLER_PRIORITY_REGISTER = 255 << 24;
@}
}%toy

The last required change is to take the new {\tt output\_p} parameter into
account to spawn the shell. Here we set its output buffer capacity to 0.

\rust{
  t.add_unchanged("fn system_call(", "fn spawn(");
}

\toy{
fn spawn(dst: &u32, name: &u32, name_length: u32,
    args: &u32, args_length: u32, output_p: &&u32) {
@  system_call(0, &dst as &u32);
@}

@static SHELL = ['s','h','e','l','l'];
@fn os_spawn_shell() {
@  let dst = os_kernel().heap_limit;
  spawn(dst, SHELL, 5, null, 0, &dst);
@}
}%toy

\rust{
  t.write_toy5("website/sources/toys_v2.txt")?;
}

\section{Compilation and tests}\label{section:streams-tests}

\rust{
  let command_editor_source = context.memory_region("command_editor_source");
  let ram_source = command_editor_source.label_address("ram_compiler_source");

  let display = Rc::new(RefCell::new(TextDisplay::default()));
  context.set_display(display.clone());
  context.micro_controller().borrow_mut().reset();
  context.run_until_get_char();

  // Start command editor.
  let command_editor_main = context
      .memory_region("command_editor")
      .label_address("command_editor");
  context.type_ascii(&format!("W{:08X}\n", command_editor_main));
  context.type_ascii("R");
  assert!(display
      .borrow()
      .get_text()
      .contains("Welcome to the command editor."));
}

Type ``F8''+``r'' in the command editor to load the current kernel source code,
and ``F4''+``r'' to edit it. Then update it as described above. For reference,
we also provide this new version in the {\tt toys\_v2.txt} file in
\toypcurl{sources.zip}. When done, type ``F10''+``r'' to save it and
``F9''+``r'' to compile it. If necessary, repeat these steps until the
compilation is successful. To copy the compiled code in the ``{\tt toys}'' file
use F3 to load the builder source code, and F4 to edit it. Then change its main
function to the following:

\rust{
  context.store_text(ram_source, &t.get_toy5());
  context.type_keys(vec!["F10"]);
  context.type_ascii("R\n");
  // F9 to compile it (stores it in flash memory too)
  context.type_keys(vec!["F9"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");

  let builder_source =
      context.get_text(context.memory_region("builder_source").start);
  let kernel_code = context.memory_region("kernel_code").start;
  let mut t = Transpiler5::new_str(&builder_source);
  t.add_unchanged("fn main() -> u32;", "static NAME = [");
  t.add_placeholder("#CODE", &format!("{}", kernel_code));
}

\toy{
static NAME = ['t','o','y','s'];
@fn main() -> u32 {
@  const COMPILED_CODE: &u32 = #CODE;
  return buffer_write(COMPILED_CODE, NAME, 4);
@}
}%toy

\rust{
  context.store_text(ram_source, &t.get_toy5());
  context.type_keys(vec!["F5"]);
  context.type_ascii("R\n");
  // F6 to compile it
  context.type_keys(vec!["F6"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");
  // F7 to run it
  context.type_keys(vec!["F7"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");

  let mut t = Transpiler5::new_str(
      &context.get_text(context.memory_region("application_source").start));
  t.add_unchanged("fn main(", "fn spawn(");
}

\noindent Finally, save the builder with F5, compile it with F6, and run it
with F7. To test the new system calls we can use two processes doing the
following:
\begin{itemize}
  \item a parent creates a file and writes some text to it. It then spawns a
  child, displays on screen the output written to standard output by its child,
  and then any character received from standard input.

  \item the child reads the above file and copies its content to standard
  output.
\end{itemize}
Each step should work and the screen should eventually display the text written
to disk by the parent. We can implement this test in a single program spawning
itself, playing the parent role if spawned without argument, or the child role
otherwise. For this use F11 to load the current ``shell'' source code, and F4
to edit it. Keep the {\tt entry} and {\tt system\_call} functions unchanged.
Add the following {\tt OK} constant and {\tt status} helper before the {\tt
spawn} function, and add an {\tt output\_p} parameter to the latter:

\toy{
const OK: u32 = 0;
fn status(result: u32) -> u32 { return result >> 24; }

fn spawn(dst: &u32, name: &u32, name_length: u32,
    args: &u32, args_length: u32, output_p: &&u32) -> u32 {
@  return system_call(0, &dst as &u32);
@}
}%toy

Then, after {\tt exit}, unchanged, add similar functions for the new system
calls:

\toy{
@fn exit(result: u32) -> u32 {
@  return system_call(1, &result);
@}
fn sleep(millis: u32) -> u32 {
  return system_call(2, &millis);
}
fn stat(name: &u32, length: u32) -> u32 {
  return system_call(3, &name as &u32);
}
fn open(name: &u32, length: u32, mode: u32) -> u32 {
  return system_call(4, &name as &u32);
}
const STANDARD_INPUT: u32 = 0;
const STANDARD_OUTPUT: u32 = 1;
const KEYBOARD: u32 = 2;
const GPU: u32 = 3;
fn read(stream_id: u32, buffer: &u32, size: u32) -> u32 {
  return system_call(5, &stream_id);
}
fn write(stream_id: u32, buffer: &u32, size: u32) -> u32 {
  return system_call(6, &stream_id);
}
fn close(stream_id: u32) -> u32 {
  return system_call(7, &stream_id);
}
fn delete(name: &u32, length: u32) -> u32 {
  return system_call(8, &name as &u32);
}
fn reboot(mode: u32) -> u32 {
  return system_call(9, &mode);
}
}%toy

Using these, add the following function to read a character from
STANDARD\_INPUT, and update {\tt draw\_char} to use the new {\tt write} system
call. This new implementation writes the following commands to the GPU stream,
in this order (see \cref{subsection:text-config,subsection:gpu-protocol}):
\begin{itemize}
  \item a Select Register command (\hexa{80}), in the 2 least significant bytes
  of {\tt buffer}.

  \item a Write Data command (\hexa{00}), in the most significant bytes.
\end{itemize}

\toy{
fn wait_char() -> u32 {
  let buffer = 0;
  read(STANDARD_INPUT, &buffer, 1);
  return buffer;
}

@fn draw_char(c: u32) -> u32 {
  let buffer = (c & 255) << 16 | (32768 /*Select Register*/ | 2);
  return write(GPU, &buffer, 4);
@}
}%toy

Then implement a function playing the parent process role:

\toy{
@static SHELL = ['s','h','e','l','l'];
static TEST = ['t','e','s','t'];
static TEXT = ['0','1','2','3','4','5','6','7','8','9'];

fn parent(heap: &u32) -> u32 {
  let stream = open(TEST, 4, 'w');
  if status(stream) != OK { return 'o'; }
  let i = 0;
  while i < 23 {
    if write(stream, TEXT, 10) != 10 { return 'w'; }
    i = i + 1;
  }
  if close(stream) != OK { return 'c'; }
  let argument = 0;
  let output = heap;
  if spawn(heap + 512, SHELL, 5, &argument, 4, &output) != OK {
    return 's';
  }
  if delete(TEST, 4) != OK { return 'd'; }
  let ptr = heap;
  while ptr < output {
    draw_char((*ptr) & 255);
    ptr = ptr + 1;
  }
  return '.';
}
}%toy

This function writes {\tt 0123456789} 23 times in a new file named ``{\tt
test}'', and closes it. It then spawns the ``{\tt shell}'' program with a 4
bytes argument equal to 0, and an output buffer for this child starting at {\tt
heap}, with a maximum capacity of 512 bytes. Finally, it deletes the file and
displays the content of this output buffer on screen. It returns '.' if
everything goes well, or a lowercase letter indicating which step failed.
Continue with a function playing the child process role:

\toy{
fn child(heap: &u32) -> u32 {
  let stream = open(TEST, 4, 'r');
  if status(stream) != OK { return 'O'; }
  let n = 0;
  loop {
    n = read(stream, heap, 64);
    if status(n) != OK { return 'R'; }
    write(STANDARD_OUTPUT, heap, n);
    if n < 64 { break; }
  }
  exit(OK);
  return 'E';
}
}%toy

This function reads the ``{\tt test}'' file, in chunks of at most 64 bytes, and
writes each chunk to standard output just after it has been read. If less than
64 bytes are read this means that the end of the file is reached. In this case
the function exits with {\tt OK} (without closing the stream; this is not
necessary since terminating a process deletes all its streams). Otherwise, or
if {\tt exit} fails, it returns an uppercase letter indicating which step
failed.

Finally, update the {\tt main} function to call the parent or the child
function, and to finally display any character read from standard input:

\toy{
@fn main(args: &u32, args_end: &u32, heap: &u32, heap_limit: &u32) -> u32 {
@  if args_end == args {
    draw_char(parent(heap));
  } else {
    draw_char(child(heap));
  }
  loop { draw_char(wait_char()); }
}
}%toy

When you are done typing this program, use F12 to save it, and F9 to compile it
(for reference we also provide it in the {\tt streams\_test.txt} file in
\toypcurl{sources.zip}). If necessary, repeat these steps until the compilation
is successful. To copy the compiled code in the ``{\tt shell}'' file and to
test it use F3 to load the builder source code, and F4 to change its main
function as follows:

\rust{
  t.write_toy5("website/sources/streams_test.txt")?;
  context.store_text(ram_source, &t.get_toy5());
  context.type_keys(vec!["F12"]);
  context.type_ascii("R\n");
  // F9 to compile it (stores it in flash memory too)
  context.type_keys(vec!["F9"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");

  let builder_source =
      context.get_text(context.memory_region("builder_source").start);
  let mut t = Transpiler5::new_str(&builder_source);
  t.add_unchanged("fn main() -> u32;", "static NAME = [");
  t.add_placeholder("#CODE", &format!("{}", kernel_code));
}

\toy{
static NAME = ['s','h','e','l','l'];
@fn main() -> u32 {
@  const COMPILED_CODE: &u32 = #CODE;
  let result = buffer_write(COMPILED_CODE, NAME, 5);
  if result == OK { flash_boot_loader_and_reset(); }
  return result;
@}
}%toy

\noindent Finally, save the builder with F5, compile it with F6, and run it
with F7. If all goes well this should launch the kernel, which should launch
our test program. The screen should display {\tt 0123456789} 23 times, followed
by a dot. Typing any key should display it on screen. After that you can reset
the Arduino, which should restart with the memory editor.

\rust{
  context.store_text(ram_source, &t.get_toy5());
  context.type_keys(vec!["F5"]);
  context.type_ascii("R\n");
  // F6 to compile it
  context.type_keys(vec!["F6"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");

  // F7 to run it -> saves file, flashes boot block, resets
  context.type_keys(vec!["F7"]);
  context.type_ascii("R");

  // Test system now running with boot loader and second kernel version
  context.run_until_get_char();
  let expected =
  "01234567890123456789012345678901234567890123456789\
   01234567890123456789012345678901234567890123456789\n\
   01234567890123456789012345678901234567890123456789\
   01234567890123456789012345678901234567890123456789\n\
   012345678901234567890123456789.";
  assert_eq!(display.borrow().get_text(), expected);

  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), String::from(expected) + "r");

  // Test reset goes back to memory editor and old system
  context.micro_controller().borrow_mut().reset();
  context.run_until_get_char();
  assert!(display.borrow().get_text().contains("20088000 00000000"));
}
