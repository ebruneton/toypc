% This work is licensed under the Creative Commons Attribution NonCommercial
% ShareAlike 4.0 International License. To view a copy of the license, visit
% https://creativecommons.org/licenses/by-nc-sa/4.0/

\renewcommand{\rustfile}{chapter8}
\setcounter{rustid}{0}

\rust{
  context.write_backup("website/backups", "native_compiler.txt")?;
}

\chapter{Native Compiler}\label{chapter:native-compiler}

Our toy programming language is now quite usable. We could continue to add new
features to make it even more usable but at some point it would stop being a
toy language, and this is not our goal. Instead of improving the language, this
chapter improves its compiler in order to generate more efficient code.

All the programs we wrote before having the first version of our compiler use
bytecode instructions, because writing native Cortex M3 code manually is very
hard. Now that we have a compiler, we no longer need to write any bytecode or
native code manually. Thus, there is no reason to continue using bytecode
instructions, in particular for the code generated by our compiler. On the
contrary, since bytecode programs are about 10 times slower than native ones
when run with our bytecode interpreter, it would be better to generate native
code. This chapter refactors our compiler in order to do this.

\section{Requirements}

In this chapter we require our compiler to compile programs into native Cortex
M3 instructions (see \cref{section:instruction-set}). We also require the
generated code to be {\em position independent}. As explained in
\cref{section:flash-driver-storage}, this means that this code should work
whatever the address at which it is run. This is not the case of the
bytecode produced by the current compiler, which only works at the
$\it{flash\_buffer}$ address used to obtain it (in particular because of the
\insn{call} instructions).

The above requirements can be achieved by using only a subset of the
instructions presented in \cref{section:instruction-set}. In some rare cases
however, in particular in the next part, some special Cortex M3 instructions
are needed. To enable this we add a last requirement, namely the possibility to
write functions directly in native code. For this we could define a syntax for
Cortex M3 instructions, such as ``{\tt MOV PC LR;}'' to denote the instruction
copying the Link Register into the Program Counter. But this would greatly
increase the size of our compiler, for a rare use case. Instead, to simplify,
we require these instructions to be given directly in encoded form, between
square brackets. For instance, compiling ``{\tt fn do\_nothing() [ 18167; ]}''
should produce a function reduced to the single ``{\tt MOV PC LR}'' instruction
(whose encoding is 18167). This syntax is not user friendly but it should
rarely be used. Comments can also make it easier to understand: ``{\tt fn
do\_nothing() [ /*MOV\_PC\_LR*/18167; ]}''.

\section{Algorithms}

The above requirements do not introduce any new token. Hence no changes are
needed in the scanner. The new syntax can be specified with a simple grammar
rule, used in {\tt fn\_body} (unchanged parts of the grammar are in gray or not
shown):

\begin{Paragraph}
\unchanged{fn\_body: ``{\tt \{}'' (const | let\_stmt | stmt)* ``{\tt \}}'' |}
fn\_asm\_body \unchanged{| ``{\tt ;}''}\\
fn\_asm\_body: ``{\tt [}'' (INTEGER ``{\tt ;}'')* ``{\tt ]}''
\end{Paragraph}

Note that we removed the syntax for imported functions. Indeed, it is no longer
possible to import, with a fixed address, a function from a program using
position independent code, which is not guaranteed to be at a fixed location.

The algorithm to parse and compile the {\tt fn\_asm\_body} rule is trivial (by
definition, each instruction simply needs to written, as is, in the $\it{dst}$
buffer). Hence, the only new algorithms which are needed are in the backend
part. They are presented below.

\subsection{Register stack}\label{subsection:register-stack}

The Cortex M3 instructions use registers to perform computations. Unfortunately
there is only a small number of registers. They can only store a very small
subset of all the values computed by a program. Hence, a native program needs
to repeatedly copy values from memory to registers, do some computation with
them, and copy the results back to memory. For instance, our bytecode
interpreter does this {\em for each bytecode instruction}. But copying values
between memory and the registers is slow, and this is a reason why our
interpreter is inefficient. To reduce the number of copies we need to keep
values in registers as long as possible, and to use all the registers (our
interpreter uses only 2 registers for actual computations, namely R0 and R1).
Unfortunately, finding an optimal way to use registers in a function is a
complex problem. The best known algorithms to solve it take a time which
increases exponentially with the size of the function. This makes them
impossible to use in practice. Instead, compilers use fast algorithms, called
{\em heuristics}, which compute a ``good enough'' solution.

In this section we define a very simple strategy to use the registers. It gives
a solution which is far from the optimal, and from the results of the best
compiler heuristics, but better than copying values back and forth for each
arithmetic or logic operation. The idea is to use the registers, other than the
SP, LR, and PC, as a stack:
\begin{itemize}
  \item at any point in time, only the first $n$ registers, R0 to R$n-1$,
  contain actual values.

  \item new values are ``pushed'' by storing them in R$n$, and incrementing $n$
  by 1.

  \item values which are no longer needed are ``popped'' by decrementing $n$ by
  1.
\end{itemize}

For instance, to compute $(1+2)*(3+4)$ we can push $1$ in R0, push $2$ in R1,
pop two values and push their sum in R0, push $3$ in R1, $4$ in R2, pop two
values and push their sum in R1, and finally pop two values and push their
product in R0 (see \cref{fig:register-stack}). This idea works well for
expressions, because intermediate results are discarded in the reverse order of
their creation. But this is not the case, in general, of function parameters or
local variables. We thus use the register stack only to compile expressions.
And we keep function parameters and local variables in the real stack. As a
consequence, the register stack is always empty at the start of each statement.

\begin{Figure}
  \input{figures/chapter8/register-stack.tex}

  \caption{Using the registers as a stack to compute
  $(1+2)*(3+4)$.}\label{fig:register-stack}
\end{Figure}

\subsection{Stack frames}\label{subsection:native-stack-frames}

With the above strategy, a statement such as ``{\tt let x = f(1, 2);}'' is
compiled into code ``pushing'' 1 and 2 in R0 and R1, before calling ``{\tt
f}''. And, by hypothesis, the effect of this call should be to ``pop'' R0 and
R1 and to ``push'' the result in R0. On the other hand, during {\tt f}'s
execution, its parameters must be on the stack, as defined above. We deduce
from this that the function arguments should be pushed on the real stack at
some point. Either the caller or the callee can do this, but doing this in the
callee saves code (there can be several call expressions for a single function).

In order to allow the callee to return at the correct instruction, the caller
should use a Branch with Link instruction, as explained in
\cref{section:registers}. And the callee should copy the LR into the PC to
return into the caller. As indicated in \cref{subsection:subroutines}, this can
be done by pushing the LR on the stack at the beginning of each function, and
by popping it into the PC to return from this function.

We implement the above choices with a single \arm{PUSH} instruction at the
beginning of each function. This instruction pushes the registers R0 to R$a-1$,
and the LR, onto the stack, where $a$ is the function's arity. This has several
consequences:
\begin{itemize}
  \item each stack frame contains, from bottom to top, the saved Link Register
  value, the function parameters {\em in reverse order}, and the local
  variables in the order they are declared (see \cref{fig:native-stack-frame}).
  The function parameters are in reverse order due to the way the \arm{PUSH}
  instruction works (see \cref{fig:push-pop-insns}).

  \item the stack frame slot index of the $i^{th}$ function parameter is $a-i$,
  instead of $i$ in the bytecode interpreter. And the stack frame slot index of
  the $i^{th}$ local variable is $a+1+i$, instead of $a+4+i$ in the interpreter
  (see \cref{fig:native-stack-frame}).

  \item function call expressions must always ``push'' their arguments in R0 to
  R$a-1$ and not, for instance, in R1 to R$a$. This is discussed in
  \cref{subsection:native-fn-call}.
\end{itemize}

\begin{Figure}
  \input{figures/chapter8/stack-frame.tex}

  \caption{Each stack frame contains the saved Link Register (blue), the
  function parameters in reverse order (gray), and the local variables (light
  gray). The address of each slot $s$ can be computed with FP$-4s$ or
  SP$+4(\it{frame\_size}-s)$ (left).}\label{fig:native-stack-frame}
\end{Figure}

\subsection{Function parameters and local
variables}\label{subsection:frame-size}

In order to use a function parameter or a local variable with stack frame slot
index $s$ we first need to compute its address on the stack. For this two
methods can be used. We can either subtract $4s$ from the Frame Pointer, or add
$4(\it{frame\_size}-s)$ to the Stack Pointer, where $\it{frame\_size}$ is the
number of slots in the stack frame, minus 1 (see
\cref{fig:native-stack-frame}). The bytecode interpreter uses the first method
because this avoids updating $\it{frame\_size}$ each time a value is pushed or
popped from the stack. Here however we don't need to update it {\em during
execution}. Instead, the compiler can keep track of its value {\em during
compilation}. Indeed, $\it{frame\_size}$ is initially equal to the function's
arity $a$, and increases by one after each {\tt let} statement. We thus use the
second method, which has the advantage of not requiring a Frame Pointer
register.

\subsection{Function calls}\label{subsection:native-fn-call}

As explained above, a function call must be compiled into code pushing the
arguments in the R0 to R$a-1$ registers, where $a$ is the function's arity.
This is what naturally happens for a statement such as ``{\tt f(1, 2);}'', but
not for ``{\tt f(1, g(2, 3));}''. In this case, before the call to {\tt g},
2 and 3 would be R1 and R2 instead of R0 and R1 (because R0 contains 1). To
solve this issue we emit code saving the register stack on the real stack
before compiling a call expression. And we emit code restoring these registers
after the call returns.

A consequence of the register stack algorithm is that a ``{\tt return $e$;}''
statement is always compiled into code pushing $e$'s value in R0. This works
fine in a case such as ``{\tt let x = f(1, 2);}'', which is supposed to pop 1
and 2 from R0 and R1, and to push the result in R0. But this does not work for
the nested call in ``{\tt f(1, g(2, 3));}''. In this case, we want the result
of {\tt g} in R1, because the arguments of {\tt f} must be in R0 and R1. To
solve this issue we emit code copying R0 into R1, before restoring R0's value
from the real stack.

In summary, a function call is compiled as follows, where $n$
is the size of the register stack, $t$ is the function's return type, and $a$
its arity (see \cref{fig:native-call}):
\begin{algorithmic}[1]
\State set $n_0$ to $n$
\State if $n>0$ emit code to \arm{PUSH} R0$\ldots$R$n-1$; increase
$\it{frame\_size}$
by $n$; set $n$ to 0
\State emit code to compute and ``push'' the arguments in R0$\ldots$R$a-1$
\State emit a Branch with Link instruction to call the function
\State if $t$ is void set $n$ to $n_0$. Otherwise write code to copy R0 in
R$n_0$; set $n$ to $n_0+1$
\State if $n_0>0$ generate code to \arm{POP} R0$\ldots$R$n_0-1$; decrease
$\it{frame\_size}$ by $n_0$
\end{algorithmic}

\begin{Figure}
  \input{figures/chapter8/function-call.tex}

  \caption{From left to right, the call to {\tt g} in {\tt f(1, 2, g(3, 4))}
  saves {\tt f}'s arguments on the stack, evaluates {\tt g}'s arguments in R0
  and R1, calls {\tt g}, copies its result from R0 to R2, and restores {\tt
  f}'s arguments from the stack.}\label{fig:native-call}
\end{Figure}

Note that this algorithm does not work if $a$ is larger than the number of
available registers. More generally, the register stack algorithm does not work
for complex expressions requiring more registers than available. In such cases,
to simplify the compiler, we simply raise an error. The user should then
refactor their code to avoid it.

In theory there are 13 available registers (the other 3 are used for the SP,
LR, and PC). In practice, however, we restrict ourselves to only 8, because
using registers R8 to R12 generally requires 32 bits instructions with complex
encodings.

\subsection{Label and function placeholders and
symbols}\label{subsection:native-placeholders}

An \insn{ifeq} instruction is encoded as one byte for the opcode, and 2 bytes
for the jump offset. When this offset is not yet known, a 16 bits placeholder
is used instead. The equivalent native code requires a ``\arm{CMP} \arm{IT}
\arm{B}'' instruction sequence, the last one containing an 11 bits offset. To
simplify we keep 16 bits placeholders, which are thus now filled with a
complete \arm{B} instruction (instead of its offset only).

Similarly, a \insn{call} instruction is encoded as one byte for the opcode, and
2 bytes for the argument. When this argument is not yet known, a 16 bits
placeholder is used instead. The equivalent native code requires a 32 bits
\arm{BL} instruction, containing a 22 bits offset split in two parts. Here
again, to simplify, we use 32 bits placeholders for complete
\arm{BL} instructions. This allows us to store, in each placeholder, the
previous placeholder's address, instead of its offset.

Currently the value of a function name symbol is the argument to use in a
\insn{call} instruction to call this function. This cannot be generalized to
the argument to use in a \arm{BL} instruction, because this argument depends on
the instruction's address (see \cref{subsection:jump-insns}). Hence we redefine
the value of a function name symbol as the $\it{dst}$ address of the function's
first instruction.

\subsection{Error handling}

The current implementation of the {\tt panic} and {\tt panic\_result} functions
assumes that each stack frame contains 4 saved register values. Since this is
not the case of the layout depicted in \cref{fig:native-stack-frame}, we need
to re-implement these functions. The general idea stays the same: {\tt
panic\_result} should save everything which is needed for {\tt panic} to return
directly in the {\tt panic\_result} caller. This includes the LR, the SP (which
replaces the FP), and nothing else. Saving the LR and the SP values is easy,
but restoring the SP is not possible unless {\tt panic} is written directly in
native code. To simplify we implement both functions in native code, and we
save the SP and LR registers in R11 and R12, respectively (they are not used
anywhere else since the register stack is restricted to R0$\ldots$R7).

\section{Implementation}\label{section:toyc5-implementation}

\rust{
  let mut t = Transpiler5::new("website/sources/types_compiler_v2.txt");
}

We can now extend our compiler in order to generate native code. As usual, this
must be done in two steps, first without using native code, then with it. To
save space, we give the two compiler versions at the same time.

Since the compiler must generate position independent code it no longer needs
the $\it{flash\_buffer}$ parameter, which is thus removed from the main
function (we keep it, unused, in the $1^{st}$ version, to simplify the
compilation steps in \cref{section:toyc5-compilation}):

\toy{
fn tc_main(src_buffer: &u32, dst_buffer: &u32) -> u32;
~fn main(src_buffer: &u32, dst_buffer: &u32/, flash_buffer: &u32//) -> u32 {
  return tc_main(src_buffer, dst_buffer);
}
}%toy

The following functions are rewritten in native code in the $2^{nd}$ version.
This is not necessary but it illustrates how {\em native functions} can be
implemented. An important thing to note is that native functions do not have a
stack frame by default. This is because they don't have a \arm{PUSH}
instruction to create this stack frame (see
\cref{subsection:native-stack-frames}), unless one is added explicitly. Most of
the time this is not necessary. Consider for instance the {\tt load8} function.
When it is called its argument is in R0 by hypothesis, and the LR contains the
return address. The result must be put in R0, which can be done with a single
\arm{LDRB} instruction (see \cref{subsection:load-store-insns}). Returning to
the caller is then done by copying the LR into the PC. The 3 other functions
are implemented in the same way.

\toy{
-@fn load8(ptr: &u32) -> u32 { return (*ptr) & 255; }
-@fn load16(ptr: &u32) -> u32 { return (*ptr) & 65535; }
-@fn store8(ptr: &u32, value: u32) { *ptr = (*ptr) & 4294967040 | value; }
-@fn store16(ptr: &u32, value: u32) { *ptr = (*ptr) & 4294901760 | value; }
+fn load8(ptr: &u32) -> u32 [ /*LDRB_R0_R0_0*/30720; /*MOV_PC_LR*/18167; ]
+fn load16(ptr: &u32) -> u32 [ /*LDRH_R0_R0_0*/34816; /*MOV_PC_LR*/18167; ]
+fn store8(ptr: &u32, value: u32) [ /*STRB_R1_R0_0*/28673; /*MOV_PC_LR*/18167; ]
+fn store16(ptr: &u32, value: u32) [ /*STRH_R1_R0_0*/32769; \
/*MOV_PC_LR*/18167; ]
}%toy

As explained above, {\tt panic\_result} copies the SP and the LR in R11 and
R12. Since it does not have its own stack frame, this copies the correct SP
value, \ie, the one from the caller. It then returns 0 in R0. When {\tt panic}
is called $\it{error}$ is in R0, which is where the {\tt panic\_result} caller
expects it. Hence {\tt panic} only needs to restore the SP from R11, and to
return in the {\tt panic\_result} caller by copying R12 into the PC.

\toy{
-@const PANIC_BUFFER: &&u32 = 1074666152;
-@fn panic_copy(src: &u32, dst: &u32) {
-@  *dst = *src;
-@  *(dst + 4) = *(src + 4);
-@  *(dst + 8) = *(src + 8);
-@  *(dst + 12) = *(src + 12);
-@}
-@fn panic_result(ptr: &u32) -> u32 {
-@  panic_copy(&ptr as &u32 - 16, ptr);
-@  *PANIC_BUFFER = ptr;
-@  return 0;
-@}
-@fn panic(error: u32) -> u32 {
-@  panic_copy(*PANIC_BUFFER, &error - 16);
-@  return error;
-@}
+fn panic_result() -> u32 [
+  /*MOV_R11_SP*/18155;
+  /*MOV_R12_LR*/18164;
+  /*MOV_R0_0*/8192;
+  /*MOV_PC_LR*/18167;
+]
+fn panic(error: u32) [ /*MOV_SP_R11*/18141; /*MOV_PC_R12*/18151; ]
}%toy

\subsection{Shared constants and data structures}

This part is unchanged except at the very end, where {\tt flash\_offset} is
removed from the {\tt Compiler} struct, and replaced with {\tt next\_register}
and {\tt frame\_size}. The former contains the register stack size noted $n$ in
\cref{subsection:register-stack}. The latter holds the $\it{frame\_size}$
variable defined in \cref{subsection:frame-size}. Unchanged parts are not
shown.

\rust{
  t.add_unchanged("const TC_INTEGER:", "\tfn_return_type: &Symbol,");
}

\toy{
@  fn_return_type: &Symbol,
  next_register: u32,
  frame_size: u32
\}
}%toy

\subsection{Backend}

\rust{
  t.add_unchanged("static TC_CHAR_TYPES =", "fn tc_write_insn(");
}

The scanner is completely unchanged and is not shown. The first 4 backend
functions, from {\tt mem\_allocate} to {\tt tc\_write32}, are unchanged and not
shown. But the rest of the backend is almost entirely rewritten. We start with
low level functions to encode and write individual instructions. Native
instructions must always be stored at even addresses. The following function
writes a 0 byte if $\it{dst}$ is odd, to make it even:

\toy{
fn tc_write_padding(self: &Compiler) {
  if self.dst as u32 & 1 == 1 { tc_write8(self, 0); }
}
}%toy

If $\it{top}=0$ the following function writes a \rs{MOVW_RD_IMM16.operation()}
instruction to store the 16 least significant bits of $c$ in R$z$. If
$\it{top}=1$ is writes a \arm{MOVT} instruction instead. It computes the
subparts $c_0$, $c_1$, $c_2$, and $c_3$ of $c$ as described in
\cref{subsection:data-insns}, and shifts them to their correct location. For
instance, ``{\tt (c {>}{>} 8) \& 7}'' computes $c_1$, which is then shifted by
$28$ bits (``{\tt \& 1}'', ``{\tt \& 7}'', ``{\tt \& 15}'', and ``{\tt \&
255}'' keep only the 1, 3, 4 and 8 least significant bits of the left hand
side, respectively).

\toy{
fn tc_write_move16_insn(self: &Compiler, z: u32, c: u32, top: u32) {
  tc_write32(self, /*MOVW_RZ_C*/62016 | (((c >> 8) & 7) << 28) |
      (z << 24) | ((c & 255) << 16) | (((c >> 11) & 1) << 10) |
      (top << 7) | ((c >> 12) & 15));
}
}%toy

The next function writes an \rs{ADD_RD_RN_RM.operation()} or
\rs{SUB_RD_RN_RM.operation()} instruction with $x=z$. $\it{op}$ must be the
instruction's encoding for $x=y=z=0$.

\toy{
fn tc_write_add_or_sub_insn(self: &Compiler, op: u32, z: u32, y: u32) {
  tc_write16(self, op | (y << 6) | (z << 3) | z);
}
}%toy

This function writes an \rs{ADD_RDN_IMM8.operation()} or
\rs{ADD_RD_SP_IMM8.operation()} instruction. $\it{op}$ must be the
instruction's encoding for $z=c=0$.

\toy{
fn tc_write_add_const_insn(self: &Compiler, op: u32, z: u32, c: u32) {
  if c > 255 { panic(100); }
  tc_write16(self, op | (z << 8) | c);
}
}%toy
\rust{
  context.add_error_code(100, "Const instruction argument overflow");
}

The following function is similar. It can be used to write a
\rs{MUL_RDM_RN.operation()}, \rs{AND_RDN_RM.operation()},
\rs{ORR_RDN_RM.operation()}, \rs{LSL_RDN_RM.operation()} or
\rs{LSR_RDN_RM.operation()} instruction:

\toy{
fn tc_write_math_insn(self: &Compiler, op: u32, z: u32, x: u32) {
  tc_write16(self, op | (x << 3) | z);
}
}%toy

The next function is intended to be used for \rs{LDR_RT_SP_IMM8.operation()}
and \rs{STR_RT_SP_IMM8.operation()}. The following one is designed for
the \rs{LDR_RT_RN_IMM5.operation()} and \rs{STR_RT_RN_IMM5.operation()}
instructions.

\toy{
fn tc_write_stack_insn(self: &Compiler, op: u32, z: u32, c: u32) {
  if c > 255 { panic(101); }
  tc_write16(self, op | (z << 8) | c);
}
fn tc_write_heap_insn(self: &Compiler, op: u32, z: u32, x: u32, c: u32) {
  if c > 31 { panic(102); }
  tc_write16(self, op | (c << 6) | (x << 3) | z);
}
}%toy
\rust{
  context.add_error_code(101, "Stack instruction argument overflow");
  context.add_error_code(102, "Heap instruction argument overflow");
}

The following function returns the encoding of a \rs{B_IMM11.operation()}
instruction jumping to $\it{target}$, to be written at $\it{dst}$. For
this it uses $c=(\it{target}-\it{pc})/2$, where $\it{pc}=\it{dst}+4$ is the PC
value when the instruction is executed. The next one does the same for a
\rs{BL_IMM22.operation()} instruction. Note that these functions return
position independent code, because the offset between $\it{dst}$ and
$\it{target}$ does not change if the code is moved elsewhere.

\toy{
fn tc_get_branch_insn(dst: &u32, target: &u32) -> u32 {
  let pc = dst + 4;
  if target >= pc + 2048 || pc > target + 2048 { panic(103); }
  return /*B_2C*/57344 | (((target - pc) & /*(1<<12)-1*/4095) >> 1);
}
fn tc_get_branch_with_link_insn(dst: &u32, target: &u32) -> u32 {
  let pc = dst + 4;
  if target >= pc + 4194304 || pc > target + 4194304 { panic(104); }
  let offset = (target - pc) & /*(1<<23)-1*/8388607;
  return /*BL_2C*/4160811008 | ((offset & 4095) << 15) | (offset >> 12);
}
}%toy
\rust{
  context.add_error_code(103, "Branch instruction argument overflow");
  context.add_error_code(104, "Branch with link instruction argument overflow");
}

The next function is unchanged, but {\tt tc\_fill\_placeholders} is rewritten
for function call placeholders only. As described above, these placeholders are
now 32 bits wide, contain the address of the previous placeholder (or {\tt
null} for the first one), and are filled with a complete \arm{BL} instruction.

\toy{
@fn tc_write_placeholder(self: &Compiler, placeholder_p: &&u32) {
@  let new_placeholder = self.dst;
@  let last_placeholder = *placeholder_p;
@  *placeholder_p = new_placeholder;
@  if last_placeholder == null { last_placeholder = new_placeholder; }
@  tc_write16(self, new_placeholder - last_placeholder);
@}
@fn tc_fill_placeholders(placeholder: &u32, value: u32) {
  let previous: &u32 = null;
@  while placeholder != null {
    previous = *placeholder as &u32;
    *placeholder = tc_get_branch_with_link_insn(placeholder, value as &u32);
    placeholder = previous;
  }
@}
}%toy

As a consequence, {\tt tc\_fill\_label\_placeholders}, which was calling the
above function, is rewritten to keep 16 bits placeholders. However, it now
fills them with complete \arm{B} instructions, as explained above.

\toy{
@fn tc_fill_label_placeholders(self: &Compiler, placeholder: &u32) {
  let offset = 0;
  while placeholder != null {
    offset = load16(placeholder);
    store16(placeholder, tc_get_branch_insn(placeholder, self.dst));
    if offset == 0 { break; }
    placeholder = placeholder - offset;
  }
@}
}%toy

We then add two functions related to the register stack. The first one
increments the register stack size and returns its previous value. The second
one writes code to push on the stack the first $n$ registers, R0 to R$n-1$, and
the LR if ${\tt link\_register}=1$. It then increments $\it{frame\_size}$ by
$n$ and clears the register stack.

\toy{
const MAX_REGISTERS: u32 = 8;
fn tc_new_register(self: &Compiler) -> u32 {
  let register = self.next_register;
  if register >= MAX_REGISTERS { panic(105); }
  self.next_register = register + 1;
  return register;
}
fn tc_save_registers(self: &Compiler, n: u32, link_register: u32) {
  tc_write16(self, /*PUSH*/46080 | (link_register << 8) | ((1 << n) - 1));
  self.frame_size = self.frame_size + n;
  self.next_register = 0;
}
}%toy
\rust{
  context.add_error_code(105, "Too many registers used");
}

The remaining functions are not new but are rewritten in order to generate
native code, thanks to the above functions. The first one writes code to push
$\it{value}$ on the register stack, while trying to minimize the size of the
generated code.

\toy{
@fn tc_write_cst_insn(self: &Compiler, value: u32) {
  let register = tc_new_register(self);
  if value < 256 {
    tc_write16(self, /*MOV_RZ_C*/8192 | (register << 8) | value);
  } else {
    tc_write_move16_insn(self, register, value, 0);
    if (value >> 16) != 0 {
      tc_write_move16_insn(self, register, value >> 16, 1);
    }
  }
@}
}%toy

The next function generates code to push $\it{dst}$ on the register stack. In
order to get position independent code, an \rs{ADR_RD_MINUS_IMM12.operation()}
instruction is used with the $\it{offset}$ between itself and $\it{dst}$ as
argument (which does not change if the code is moved). As required by
\arm{ADR}, $\it{offset}$ is computed as $\lfloor\mathrm{PC}\rfloor_4-\it{dst}$,
where $\mathrm{PC}$ is the instruction's address plus 4.

\toy{
@fn tc_write_static_insn(self: &Compiler, dst: u32) {
  let z = tc_new_register(self);
  let offset = (((self.dst as u32 + 4) >> 2) << 2) - dst;
  if offset > 4095 { panic(106); }
  tc_write32(self, /*ADR_RZ_C*/62127 | (((offset >> 8) & 7) << 28) |
      (z << 24) | ((offset & 255) << 16) | (((offset >> 11) & 1) << 10));
@}
}%toy
\rust{
  context.add_error_code(106, "Static instruction argument overflow");
}

The next function writes code which pops the top 2 registers R$z$ and R$y$,
combines them with the operation corresponding to $\it{token}$, and pushes the
result back in R$z$.

\toy{
@fn tc_write_binary_insn(self: &Compiler, token: u32) {
  let y = self.next_register - 1;
  let z = y - 1;
  if token == TC_ADD {
    tc_write_add_or_sub_insn(self, /*ADD_RZ_RX_RY*/6144, z, y);
  } else if token == TC_SUB {
    tc_write_add_or_sub_insn(self, /*SUB_RZ_RX_RY*/6656, z, y);
  } else if token == TC_MUL {
    tc_write_math_insn(self, /*MUL_RZ_RZ_RX*/17216, z, y);
  } else if token == TC_DIV {
    tc_write32(self, /*UDIV_RZ_RX_RY*/4042324912 | z << 24 | y << 16 | z);
  } else if token == TC_BIT_AND {
    tc_write_math_insn(self, /*AND_RZ_RZ_RX*/16384, z, y);
  } else if token == TC_BIT_OR {
    tc_write_math_insn(self, /*ORR_RZ_RZ_RX*/17152, z, y);
  } else if token == TC_SHIFT_LEFT {
    tc_write_math_insn(self, /*LSL_RZ_RZ_RX*/16512, z, y);
  } else {
    tc_write_math_insn(self, /*LSR_RZ_RZ_RX*/16576, z, y);
  }
  self.next_register = y;
@}
}%toy

A conditional jump requires 3 instructions in native code. A \arm{CMP} and an
\arm{IT} instruction are needed to skip a \arm{B} instruction (here a
placeholder) if the top 2 registers do not meet the jump condition (these
registers are necessarily R0 and R1 since boolean expressions can't be used
in other expressions). {\tt IF\_THEN\_CONDITION} contains the \arm{IT}
arguments corresponding to the $<$, $=$, $>$, $\le$, $\ne$, and $\ge$
conditions, respectively (see \cref{subsection:conditional-insns}).

\toy{
static IF_THEN_CONDITION = [48, 0, 128, 144, 16, 32];
@fn tc_write_jump_insn(self: &Compiler, token: u32, placeholder_p: &&u32) {
  tc_write16(self, /*CMP_R0_R1*/17032);
  tc_write16(self, /*IT*/48904 | load8(IF_THEN_CONDITION + token - TC_LT));
@  tc_write_placeholder(self, placeholder_p);
  self.next_register = 0;
@}
@fn tc_write_goto_insn(self: &Compiler, placeholder_p: &&u32) {
  tc_write_placeholder(self, placeholder_p);
@}
@fn tc_write_loop_insn(self: &Compiler, loop_dst: &u32) {
  tc_write16(self, tc_get_branch_insn(self.dst, loop_dst));
@}
}%toy

On the other hand, loading the value of a field can be done with a single
native instruction, instead of 3 bytecode instructions. Indeed a single
\arm{LDR} instruction can add $4.\it{field}$ to the struct's address, popped
from the register stack, and push back the value at the resulting
address.

\toy{
@fn tc_write_load_insn(self: &Compiler, field: u32) {
  let z = self.next_register - 1;
  tc_write_heap_insn(self, /*LDR_RZ_RX_4C*/26624, z, z, field);
@}
}%toy

Erasing a load instruction was previously erasing only the $3^{rd}$ instruction
written by {\tt tc\_write\_load\_insn}. This was leaving the field's address on
the stack which, consequently, didn't have to be recomputed to store a value in
it. Erasing a load instruction now deletes it completely. The field address
must thus be recomputed in the following function. This is done with a
\arm{STR} instruction, adding $4.\it{field}$ to the struct's address in R$x$,
and storing R$z$ at the resulting address. Since {\tt tc\_write\_store\_insn}
is only used to compile assignments, and since the register stack is always
empty at the start of a statement, we necessarily have $x=0$ and $z=1$.

\toy{
fn tc_erase_load_insn(self: &Compiler) { self.dst = self.dst - 2; }
@fn tc_write_store_insn(self: &Compiler, field: u32) {
  tc_write_heap_insn(self, /*STR_RZ_RX_4C*/24576, 1, 0, field);
  self.next_register = 0;
@}
}%toy

For the same reason the following function, called after {\tt
tc\_erase\_load\_insn}, and which previously had nothing to do, must now write
an instruction adding $4.\it{field}$ to the top register:

\toy{
@fn tc_write_address_of_insn(self: &Compiler, field: u32) {
  let z = self.next_register - 1;
  if field != 0 {
    tc_write_add_const_insn(self, /*ADD_RZ_RZ_C*/12288, z, field << 2);
  }
@}
}%toy

As explained in \cref{subsection:frame-size} a function parameter or local
variable is now accessed by adding $4(\it{frame\_size}-\it{variable})$ to the
SP, where $\it{variable}$ is its stack frame slot index. Note that the register
stack size is always 1 when {\tt tc\_write\_set\_insn} and {\tt
tc\_write\_pop\_insn} are called (they are only used to compile assignment and
expression {\em statements}, respectively).

\toy{
@fn tc_write_ptr_insn(self: &Compiler, variable: u32) {
  tc_write_add_const_insn(self, /*ADD_RZ_SP_4C*/43008,
      tc_new_register(self), self.frame_size - variable);
@}
@fn tc_write_get_insn(self: &Compiler, variable: u32) {
  tc_write_stack_insn(self, /*LDR_RZ_SP_4C*/38912,
      tc_new_register(self), self.frame_size - variable);
@}
@fn tc_erase_get_insn(self: &Compiler) {
  self.dst = self.dst - 2;
  self.next_register = self.next_register - 1;
@}
@fn tc_write_set_insn(self: &Compiler, variable: u32) {
  tc_write_stack_insn(self, /*STR_RZ_SP_4C*/36864, 0, \
self.frame_size - variable);
  self.next_register = 0;
@}
fn tc_write_pop_insn(self: &Compiler) { self.next_register = 0; }
}%toy

The next function writes a \arm{PUSH} instruction at the beginning of a
function to create its stack frame, initially containing the function
parameters and the saved Link Register value. The value of a function name
symbol is now $\it{fn\_dst}$ (see \cref{subsection:native-placeholders}).

\toy{
@fn tc_write_fn_insn(self: &Compiler, arity: u32) {
  if arity > MAX_REGISTERS { panic(107); }
  self.frame_size = 0;
  tc_save_registers(self, arity, 1);
@}
fn tc_get_fn_value(self: &Compiler, fn_dst: u32) -> u32 { return fn_dst; }
}%toy
\rust{
  context.add_error_code(107, "Too many function parameters");
}

The next function implements steps 4 to 6 of the algorithm in
\cref{subsection:native-fn-call} (the new $\it{saved\_registers}$ parameter
corresponds to $n_0$; steps 1 to 3 are done by the caller).

\toy{
fn tc_write_call_insn(self: &Compiler, function: &Symbol, saved_registers: u32)
{
  let dst = self.dst;
  if function.kind == SYM_FORWARD_FN {
    tc_write32(self, function.value);
    function.value = dst as u32;
  } else {
    tc_write32(self, tc_get_branch_with_link_insn(dst, function.value as &u32));
  }
  if function.type.kind != SYM_VOID {
    if saved_registers != 0 {
      tc_write16(self, /*MOV_RZ_R0*/17920 | saved_registers);
    }
    if saved_registers >= MAX_REGISTERS { panic(108); }
    self.next_register = saved_registers + 1;
  } else {
    self.next_register = saved_registers;
  }
  if saved_registers != 0 {
    tc_write16(self, /*POP*/48128 | ((1 << saved_registers) - 1));
    self.frame_size = self.frame_size - saved_registers;
  }
}
}%toy
\rust{
  context.add_error_code(108, "Too many function arguments");
}

In order to return from a function the first step is to adjust the SP to point
to the saved LR value, at the bottom of the function's stack frame. Popping
this value into the PC then returns to the caller.

\toy{
@fn tc_write_return_insn(self: &Compiler) {
  let offset = self.frame_size;
  if offset > 127 { panic(109); }
  if offset != 0 { tc_write16(self, /*ADD_SP_SP_4C*/45056 | offset); }
  tc_write16(self, /*POP_PC*/48384);
  self.next_register = 0;
@}
}%toy
\rust{
  context.add_error_code(109, "Return instruction argument overflow");
}

\subsection{Parser}

The parser is extended in order to support native functions. We also add the
possibility to use function names in expressions, which evaluate to their
address. Finally, a few parser functions need to be updated due to the changes
in the backend. The first one is {\tt tc\_parse\_static}. Native instructions
must be stored at even addresses, but a {\tt static} block may add an odd
number of bytes between instructions. To fix this we add some padding if
necessary (unchanged functions are not shown; an ellipsis replaces some
unchanged statements):

\rust{
  t.add_unchanged("fn sym_lookup(", "fn tc_parse_static(");
}

\toy{
@fn tc_parse_static(self: &Compiler) {
@  tc_parse_token(self, TC_STATIC);
...@  let length = 0;
...@  let name = tc_parse_identifier(self, &length);
...@  tc_add_symbol(self, name, length, SYM_STATIC, self.dst as u32, null, 1);
...@  tc_parse_token(self, '=');
...@  tc_parse_token(self, '[');
...@  tc_write8(self, tc_parse_integer(self));
...@  while self.next_token == ',' {
...@    tc_read_token(self);
...@    tc_write8(self, tc_parse_integer(self));
...@  }
...@  tc_parse_token(self, ']');
@  tc_parse_token(self, ';');
  tc_write_padding(self);
@}
}%toy

\rust{
  t.add_unchanged("fn tc_parse_struct(", "fn tc_push_symbol_value(");
}

In order to support function names as {\tt u32} expressions we add a special
case for {\tt SYM\_FN} symbols in the following function:

\toy{
@fn tc_push_symbol_value(self: &Compiler, symbol: &Symbol) -> &Value {
...@  let origin = FROM_OTHER;
...@  if symbol.kind == SYM_FIELD { origin = FROM_ADDRESS; }
...@  else if symbol.kind == SYM_VARIABLE { origin = FROM_VARIABLE; }
...@  else if symbol.kind == SYM_VOID { origin = FROM_VOID; }
  if symbol.kind == SYM_FN {
    return tc_push_value(self, origin, symbol.value, null, 0);
  }
@  return tc_push_value(self, origin, symbol.value, symbol.type, symbol.dim);
@}
}%toy

\rust{
  t.add_unchanged("fn tc_top_value(", "fn tc_parse_fn_arguments(");
}

The function below is updated to write code saving the register stack on the
real stack (steps 1 and 2 in \cref{subsection:native-fn-call}) before compiling
the function arguments:

\toy{
@fn tc_parse_fn_arguments(self: &Compiler, function: &Symbol) {
...@  if function.kind != SYM_FN && function.kind != SYM_FORWARD_FN {
...@    panic(34);
...@  }
@  tc_parse_token(self, '(');
  let next_register = self.next_register;
  if next_register != 0 {
    tc_save_registers(self, next_register, 0);
  }
@  let argument_count = 0;
@  while self.next_token != ')' {
@    if argument_count > 0 { tc_parse_token(self, ','); }
@    tc_parse_expr(self);
@    argument_count = argument_count + 1;
@  }
@  tc_read_token(self);
@  tc_check_fn_arguments(self, function, argument_count);
  tc_write_call_insn(self, function, next_register);
@}
}%toy

\rust{
  t.add_unchanged("fn tc_parse_sizeof_expr(", "fn tc_parse_primitive_expr(");
}

Another change is needed in the following function in order allow {\tt SYM\_FN}
symbols in expressions (which can be compiled in the same way as {\tt
SYM\_STATIC} symbols).

\toy{
@fn tc_parse_primitive_expr(self: &Compiler) {
@  let symbol: &Symbol = null;
...@  if self.next_token == TC_INTEGER {
...@    tc_push_value(self, FROM_OTHER, 0, null, 0);
...@    tc_write_cst_insn(self, tc_parse_integer(self));
...@  } else if self.next_token == TC_IDENTIFIER {
...@    symbol = tc_parse_symbol(self, self.symbols);
...@    if self.next_token == '(' {
...@      tc_parse_fn_arguments(self, symbol);
...@    } else {
...@      tc_push_symbol_value(self, symbol);
...@      if symbol.kind == SYM_VARIABLE {
...@        tc_write_get_insn(self, symbol.value);
...@      } else if symbol.kind == SYM_CONST {
...@        tc_write_cst_insn(self, symbol.value);
      } else if symbol.kind == SYM_STATIC || symbol.kind == SYM_FN {
@        tc_write_static_insn(self, symbol.value);
...@      } else {
...@        panic(35);
...@      }
...@    }
...@  } else if self.next_token == TC_SIZEOF {
...@    tc_parse_sizeof_expr(self);
...@  } else if self.next_token == TC_NULL {
...@    tc_read_token(self);
...@    tc_push_value(self, FROM_NULL, 0, null, 0);
...@    tc_write_cst_insn(self, 0);
...@  } else {
...@    tc_parse_token(self, '(');
...@    tc_parse_expr(self);
...@    tc_parse_token(self, ')');
...@  }
@}
}%toy

\rust{
  t.add_unchanged("fn tc_parse_path_expr(", "fn tc_parse_let_stmt(");
}

The function compiling a {\tt let} statement must also be updated, in order to
generate code pushing on the stack the right hand side value, in R0 (this value
was previously produced directly on the stack).

\toy{
@fn tc_parse_let_stmt(self: &Compiler, variable: u32) -> u32 {
@  tc_parse_token(self, TC_LET);
...@  let length = 0;
...@  let name = tc_parse_identifier(self, &length);
...@  let separator = self.next_token;
...@  let type: &Symbol = null;
...@  let dim = 0;
...@  if separator == ':' {
...@    tc_read_token(self);
...@    type = tc_parse_type(self, &dim);
...@  }
...@  tc_parse_token(self, '=');
...@  tc_parse_expr(self);
...@  tc_parse_token(self, ';');
...@  let value = tc_pop_value(self);
...@  if separator == ':' {
...@    value_type_check(value, type, dim);
...@  } else {
...@    if value.origin == FROM_NULL { panic(57); }
...@    type = value.type;
...@    dim = value.dim;
...@  }
@  tc_add_symbol(self, name, length, SYM_VARIABLE, variable, type, dim);
  tc_save_registers(self, 1, 0);
@  return variable + 1;
@}
}%toy

\rust{
  t.add_unchanged("fn tc_parse_fn_name(", "fn tc_parse_fn_body(");
}

A new function is added just before {\tt tc\_parse\_fn\_body}. It parses and
compiles the new syntax for native functions. Each integer simply needs to be
written in the $\it{dst}$ buffer, using either 16 or 32 bits depending on its
value (32 bits instructions have bits 11 to 15 greater than $11100_2=28$ --
see Section A5.3 pA5-137 of \cite{ARMv7}).

\toy{
fn tc_parse_fn_asm_body(self: &Compiler) {
  let value = 0;
  tc_parse_token(self, '[');
  while self.next_token != ']' {
    value = tc_parse_integer(self);
    if (value >> 11) & 31 > 28 {
      tc_write32(self, value);
    } else {
      tc_write16(self, value);
    }
    tc_parse_token(self, ';');
  }
  tc_read_token(self);
}
}%toy

It is used in the next function, which is also updated to compute the function
parameter and local variable slot indices as described in
\cref{subsection:native-stack-frames}.

\toy{
@fn tc_parse_fn_body(self: &Compiler, function: &Symbol, arity: u32) {
@  if self.next_token == ';' {
...@    tc_read_token(self);
...@    function.kind = SYM_FORWARD_FN;
...@    function.value = 0;
...@    return;
@  }
  if self.next_token == '[' {
    tc_parse_fn_asm_body(self);
    return;
  }
@  let parameter = function.type.next;
@  while parameter != null {
@    tc_add_symbol(self, parameter.name, parameter.length, SYM_VARIABLE,
        arity - parameter.value, parameter.type, parameter.dim);
@    parameter = parameter.next;
@  }
@  tc_parse_token(self, '\{');
@  tc_write_fn_insn(self, arity);
  let next_variable = arity + 1;
...@  let state = END_REACHABLE;
...@  while self.next_token != '\}' {
...@    if state == END_UNREACHABLE { panic(40); }
...@    if self.next_token == TC_CONST {
...@      tc_parse_const(self);
...@    } else if self.next_token == TC_LET {
...@      next_variable = tc_parse_let_stmt(self, next_variable);
...@    } else {
...@      state = tc_parse_stmt(self, null);
...@    }
...@  }
...@  if state == END_REACHABLE {
...@    if self.fn_return_type.kind != SYM_VOID { panic(41); }
...@    tc_write_return_insn(self);
...@  }
...@  tc_read_token(self);
@}
}%toy

\rust{
  t.add_unchanged("fn tc_check_symbols(", "fn tc_main(");
}

Finally, the 4 $\it{panic}$ variables are removed from the main function, since
they are no longer needed by the native {\tt panic\_result} function. The
$\it{flash\_buffer}$ parameter is also removed, and a test is added to make
sure that $\it{dst\_buffer}$ is {\em word aligned}, \ie, is a multiple of 4.
Indeed the generated code is not fully position independent: it can only be
moved by $\pm 4n$ bytes, due to the \arm{ADR} instruction. We assume here that
it will be run at a word aligned address, which requires it to generated at
such an address.

\toy{
fn tc_main(src_buffer: &u32, dst_buffer: &u32) -> u32 {
...@  let error = 0;
...@  let compiler = (dst_buffer + 12288) as &Compiler;
...@  compiler.src = src_buffer + 3;
...@  compiler.src_end = src_buffer + 4 + *src_buffer;
...@  compiler.dst = dst_buffer + 4;
...@  compiler.dst_limit = compiler as &u32;
...@  compiler.heap = compiler.dst_limit + sizeof(Compiler);
...@  compiler.heap_limit = compiler.heap + 18432;
@  compiler.symbols = null;
-  let panic3 = 0;
-  let panic2 = 0;
-  let panic1 = 0;
-  let panic0 = 0;
~  error = panic_result(/&panic0//);
...@  if error != 0 {
...@    *dst_buffer = compiler.src - src_buffer - 4;
...@    return error;
...@  }
  if (dst_buffer as u32) & 3 != 0 { panic(110); }
@  tc_read_char(compiler);
...@  tc_read_token(compiler);
...@  tc_parse_program(compiler);
...@  *dst_buffer = compiler.dst - dst_buffer - 4;
...@  return 0;
@}
}%toy
\rust{
  context.add_error_code(110, "Unaligned destination buffer");
}

\rust{
  t.write_toy4("website/sources/native_compiler_v1.txt")?;
  t.write_toy5("website/sources/native_compiler_v2.txt")?;
  fs::write("generated/error_codes_table.tex",
      context.get_error_codes_table())?;
}

\section{Compilation and tests}\label{section:toyc5-compilation}

\rust{
  let boot_mode_address = context.memory_region("foundations")
      .label_address("boot_mode_select_rom");

  let display = Rc::new(RefCell::new(TextDisplay::default()));
  context.set_display(display.clone());
  context.micro_controller().borrow_mut().reset();
  context.run_until_get_char();

  let mut context1 = context.clone();

  // Launch the command editor
  let command_editor_main =
      context.memory_region("command_editor").label_address("command_editor");
  context.type_ascii(&format!("W{:08X}\n", command_editor_main));
  context.type_ascii("R");
}

To compile the above source code proceed as follows (see also
\cref{fig:compilation-and-test}).

\medskip \paragraph*{Edit v1} In the command editor, type ``F3''+``r'' and
``F4''+``r'' to load and edit the current compiler version. Then update it to
the $1^{st}$ version of the native compiler. For convenience, we also provide
this code in the {\tt native\_compiler\_v1.txt} file in \toypcurl{sources.zip}.
When you are done, exit the text editor and type ``F5''+``r'' to save your
work. Alternatively, you can ``cheat'' by running the following command on an
external computer (see \cref{section:toyc1-compilation} for more details):

\rust{
  // Enter source code in RAM, as if edited with F4 command.
  let ram_compiler_source = context.memory_region("command_editor_source")
      .label_address("ram_compiler_source");
  let toyc5_dot_toy4 = std::fs::read_to_string(
      "website/sources/native_compiler_v1.txt")?;
  context.store_text(ram_compiler_source, toyc5_dot_toy4.as_str());

  // Save it in flash.
  context.type_keys(vec!["F5"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");

  // Alternative method.
  context1.micro_controller().borrow_mut().reset();
  context1.run_until_get_char();
  context1.type_ascii(&format!("W{:08X}\n", boot_mode_address));
  context1.type_ascii("R");
  context1.micro_controller().borrow_mut().reset();

  let compiler_source = context.memory_region("compiler_source").start;
  write_lines("website/part3", "native_compiler_v1.txt",
      &flash_helper_commands(&toyc5_dot_toy4, compiler_source))?;
  let mut flash_helper1 = FlashHelper::from_file(context1.micro_controller(),
      "website/", "part3/native_compiler_v1.txt")?;
  let log = flash_helper1.read();

  // Check that both methods give the same result.
  context.check_equal_buffer(&mut context1, compiler_source);
}
\rs{host_log(log.lines().next().unwrap())}

\medskip \paragraph{Compile v1} In the command editor, type ``F6''+``r'' to
compile the code you typed. If all goes well, after about 4 seconds, you should
get a result equal to 0 (meaning that no error was found). If this is not the
case use \cref{appendix:compilercodes} to get the error code meaning, fix this
error, save the program and compile it again. Repeat this process until the
compilation is successful. Then type ``F7''+``r'' to save the result.

\rust{
  // Compile it with toyc4.
  context.type_keys(vec!["F6"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");

  // Save it in flash memory.
  context.type_keys(vec!["F7"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");
}

\medskip \paragraph{Test v1} Type ``F2''+``r'' to create a new program,
``F4''+``r'' to edit it, and type the following small test program, which
computes the factorial of 6:

\rust{
  let test_program = r"fn factorial(n: u32) -> u32;
fn test() -> u32 { return factorial(6); }
fn factorial(n: u32) -> u32 {
  if n == 0 { return 1; }
  return factorial(n - 1) * n;
}";
  // Enter source code in RAM, as if edited with F4 command.
  context.store_text(ram_compiler_source, test_program);
}
\rs{code(test_program)}

Compiling this program with the native compiler is easy, but running it is
harder since its compiled code is using native instructions. One issue is that
this code uses some registers also used by the bytecode interpreter. Another is
that it returns the result in R0, but a command must return it on the stack. To
solve these issues we need a small adapter subroutine using native code:

\rust{
  const R0: u32 = 0;
  const R1: u32 = 1;
  let mut a = Assembler::new(0);
  a.push_list(&[0, 1, 2, 3, 4, 5, 6], true);
  a.ldr_rt_pc_imm8(R0, "program_address");
  a.blx_rm(R0);
  a.ldr_rt_pc_imm8(R1, "result_address");
  a.str_rt_rn_imm5(R0, R1, 0);
  a.pop_list(&[0, 1, 2, 3, 4, 5, 6], true);
  a.label("program_address");
  a.u32_data(0, "program address");
  a.label("result_address");
  a.u32_data(0, "result address");
}
\rs{a.get_listing(0..a.get_instruction_count() as usize)}

\rs{a.get_machine_code_listing(0..a.get_instruction_count() as usize)}

This subroutine saves the registers used by the bytecode interpreter (and the
LR), loads the interworking address of the test program in R0, calls it, loads
an address where to store the result in R1, and stores it here. Finally, it
restores the saved registers and returns. It is followed by two placeholders
for the program and result addresses. To run it we can store it on the stack,
as we did for the {\tt page\_flash} function. For this, type ``F9''+``e'' to
edit this command and change its code to the following:

\rust{
  let compiler_code = context.memory_region("compiler_code").start;
  let compiler_code_end = context.memory_region("compiler_code").end();
  let command_editor_source = context.memory_region("command_editor_source");
  let ram_command_source =
      command_editor_source.label_address("ram_command_source");
  let ram_compiler_code =
      command_editor_source.label_address("ram_compiler_code");
  let asm_words = a.machine_code();
  assert_eq!(asm_words.len(), 5);

  // Test compiler with small test program, in F9.
  context.type_keys(vec!["F9"]);
  let mut c = BytecodeAssembler::default();
  c.import_labels(context.memory_region("compiler_code"));
  c.func("test_compiler", &[], "", &[]);
  // compile test program
  c.new_line();
  c.cst(ram_compiler_source); // src_buffer
  c.cst(ram_compiler_code); // dst_buffer
  c.cst(compiler_code_end); // flash_buffer (ignored)
  c.call("main");
  c.def("result");
  // if error, return it
  c.new_line();
  c.get("result");
  c.cst_0();
  c.ifne("test_compiler_end");
  c.new_line();
  c.ptr("result");
  c.def("word4");
  c.cst(ram_compiler_code + 4 + 1); // +1 for interworking address
  c.def("word3");
  c.cst(asm_words[2]);
  c.def("word2");
  c.cst(asm_words[1]);
  c.def("word1");
  c.cst(asm_words[0]);
  c.def("word0");
  // Compute interworking address of adapter subroutine and call it.
  c.new_line();
  c.ptr("word0");
  c.cst_1();
  c.add();
  c.blx();
  // return result
  c.label("test_compiler_end");
  c.get("result");
  c.retv();
  let c_source = format!("{}\nd TEST_COMPILER", c.get_toy0_source_code());
  context.store_text(ram_command_source, &c_source);
  context.type_keys(vec!["S"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "000002D0");
  context.type_ascii("\n");

  // Test compilation errors (this also tests the panic functions).
  let mut context2 = context.clone();
  context2.store_text(ram_compiler_source,
      &test_program.replace("test() -> u32", "test() -> &u32"));
  context2.type_ascii("R");
  assert_eq!(context2.get_display().borrow().get_text(), "0000002B");
}
\rs{code(&c_source)}

Then type Escape and ``s'' to save it. The $3^{rd}$ line of the function's body
pushes each word of the subroutine code on the stack, in reverse order (\ie,
starting with the result address, and the test program interworking address
\rs{hex(ram_compiler_code)}+4+1). The next line computes the interworking
address of this subroutine and calls it. Note that we run the test program
directly in RAM, instead of at the $\mathit{flash\_buffer}$ address used to
compile it (which is in fact ignored). This is possible because its native code
is position-independent.

Finally, type ``r'' to run this command. If the result is not
\rs{dec_hex(720u32)} this means that the compiler is wrong. In this case, type
``F8''+``r'' to restore the types compiler. Then repeat the previous steps and
double check everything until this test passes.

\medskip \paragraph*{Edit v2} Type ``F3''+``r'' to load the $1^{st}$ version of
the native compiler and ``F4''+``r'' to edit it. Then update it to the
$2^{nd}$ version. For convenience, we also provide this code in the {\tt
  native\_compiler\_v2.txt} file. Then save this new version with the F5
command. Alternatively, run the following command on an external computer:

\rust{
  // Enter source code in RAM, as if edited with F4 command.
  let toyc5_dot_toy5 = std::fs::read_to_string(
      "website/sources/native_compiler_v2.txt")?;
  context.store_text(ram_compiler_source, toyc5_dot_toy5.as_str());

  // Save it in flash.
  context.type_keys(vec!["F5"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");

  // Alternative method.
  context1.run_until_get_char();
  context1.type_ascii(&format!("W{:08X}\n", boot_mode_address));
  context1.type_ascii("R");
  context1.micro_controller().borrow_mut().reset();

  write_lines("website/part3", "native_compiler_v2.txt",
      &flash_helper_commands(&toyc5_dot_toy5, compiler_source))?;
  let mut flash_helper1 = FlashHelper::from_file(context1.micro_controller(),
      "website/", "part3/native_compiler_v2.txt")?;
  let log = flash_helper1.read();

  // Check that both methods give the same result.
  context.check_equal_buffer(&mut context1, compiler_source);
}
\rs{host_log(log.lines().next().unwrap())}

\medskip \paragraph*{Compile v2} Type``F6''+``r'' to compile this new code. The
result should be 0, meaning ``no error''. If this is not the case, repeat the
``Edit v2'' and ``Compile v2'' steps until all errors are fixed.

\rust{
  // Compile v2.
  context.type_keys(vec!["F6"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");
}

\medskip \paragraph*{Test v2} As in the previous chapter, the compiled
code of the $2^{nd}$ version of the native compiler is not identical to
that of the $1^{st}$ version. The obvious reason is that the former (produced
by the native compiler) uses native instructions, while the latter (produced by
the types compiler) uses bytecode instructions.

To test the $2^{nd}$ version we can check that it produces the same native code
as the $1^{st}$ for the same input program, namely the $2^{nd}$ version of the
native compiler itself. We already have the $2^{nd}$ version compiled by the
$1^{st}$. To get the $2^{nd}$ version compiled by itself we need a small
adapter subroutine, as in the ``Test v1'' step:

\rust{
  const R2: u32 = 2;
  let mut a = Assembler::new(0);
  a.push_list(&[0, 1, 2, 3, 4, 5, 6], true);
  a.ldr_rt_pc_imm8(R0, "src_buffer");
  a.ldr_rt_pc_imm8(R1, "dst_buffer");
  a.ldr_rt_pc_imm8(R2, "program_address");
  a.blx_rm(R2);
  a.ldr_rt_pc_imm8(R1, "result_address");
  a.str_rt_rn_imm5(R0, R1, 0);
  a.pop_list(&[0, 1, 2, 3, 4, 5, 6], true);
  a.label("program_address");
  a.u32_data(0, "program address");
  a.label("src_buffer");
  a.u32_data(0, "src buffer");
  a.label("dst_buffer");
  a.u32_data(0, "dst buffer");
  a.label("result_address");
  a.u32_data(0, "result address");
}
\rs{a.get_listing(0..a.get_instruction_count() as usize)}

\rs{a.get_machine_code_listing(0..a.get_instruction_count() as usize)}

This subroutine saves the registers used by the bytecode interpreter (and the
LR). It then loads the native compiler's parameters in R0 and R1, and its
interworking address in R2, calls this compiler, loads an address where to
store its result in R1, and stores it here. Finally, it restores the saved
registers and returns. It is followed by placeholders for the program address,
its arguments, and a result address. To run it type ``F9''+``e'' to edit this
command and change its code to the following:

\rust{
  let dst_buffer = ram_compiler_code + 12 * 1024;
  let asm_words = a.machine_code();
  context.add_program("native_compiler_wrapper", a);
  assert_eq!(asm_words.len(), 8);

  context.type_keys(vec!["F9"]);
  let mut c = BytecodeAssembler::default();
  c.import_labels(context.memory_region("compiler_code"));
  c.func("test_compiler", &[], "", &[]);
  c.new_line();
  c.cst_0();
  c.def("result");
  // compile test program
  c.new_line();
  c.ptr("result");
  c.def("word7");
  c.cst(dst_buffer); // dst_buffer
  c.def("word6");
  c.cst(ram_compiler_source); // src_buffer
  c.def("word5");
  c.cst(ram_compiler_code + 4 + 1); //+1 for interworking address
  c.def("word4");
  c.new_line();
  c.cst(asm_words[3]);
  c.def("word3");
  c.cst(asm_words[2]);
  c.def("word2");
  c.cst(asm_words[1]);
  c.def("word1");
  c.cst(asm_words[0]);
  c.def("word0");
  // Compute interworking address of wrapper and call it.
  c.new_line();
  c.ptr("word0");
  c.cst_1();
  c.add();
  c.blx();
  // return result
  c.new_line();
  c.get("result");
  c.retv();
  let c_source = format!("{}\nd TEST_COMPILER", c.get_toy0_source_code());
  context.store_text(ram_command_source, &c_source);
  context.type_keys(vec!["S"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");
}
\rs{code(&c_source)}

Then type Escape and ``s'' to save it. The first line of the function's body
initializes the result value to 0. The next two lines push the subroutine data
and instructions, in reverse order. We use as program address the interworking
address of the $2^{nd}$ version of the native compiler
(\rs{hex(ram_compiler_code)}+4+1), as $\it{src\_buffer}$ its source code
(\rs{hex(ram_compiler_source)}), and as $\it{dst\_buffer}$ a RAM region 12~KB
after the program address (\rs{hex(dst_buffer)}).

Finally, type ``r'' to run this command, \ie, to compile the $2^{nd}$ version
with itself. The result should be zero. You should also get it in a fraction of
a second, instead of about 4 seconds in the ``Compile v2'' step. This is
because native code is much faster than our bytecode interpreter. If the result
is not 0 repeat the previous steps from ``Edit v2'' and double check everything.

To check if the generated code, at address \rs{hex(dst_buffer)}, is identical
to that produced with the $1^{st}$ version (at address
\rs{hex(ram_compiler_code)}) we need to update the ``F10'' command first (this
command currently compares the buffers at addresses \rs{hex(compiler_code)} and
\rs{hex(ram_compiler_code)}). Type ``F10''+``e'' to edit it and change its
second line as follows:

\rust{
  let mut c = BytecodeAssembler::create(RegionKind::Default, 0xC0000, true);
  c.import_labels(context.memory_region("graphics_card_driver"));
  c.func("compare_compiled_code", &[], "", &["nolink"]);
  c.new_line();
  c.cst(ram_compiler_code);
  c.def("ptr1");
  c.cst(dst_buffer);
  c.def("ptr2");
  // let size = *ptr1 + 4;
  c.new_line();
  c.get("ptr1");
  c.load();
  c.cst8(4);
  c.add();
  c.def("size");
  // let i = 0;
  c.new_line();
  c.cst_0();
  c.def("i");
  // while i < size && *(ptr1 + i) == *(ptr2 + i)
  c.new_line();
  c.label("test_equal_code_loop");
  c.get("i");
  c.get("size");
  c.ifge("test_equal_code_end");
  c.new_line();
  c.get("ptr1");
  c.get("i");
  c.add();
  c.call("load_byte");
  c.get("ptr2");
  c.get("i");
  c.add();
  c.call("load_byte");
  c.ifne("test_equal_code_end");
  // i = i + 1;
  c.new_line();
  c.cst_1();
  c.add();
  c.goto("test_equal_code_loop");
  // return size - i;
  c.new_line();
  c.label("test_equal_code_end");
  c.get("size");
  c.get("i");
  c.sub();
  c.retv();
  let c_source = format!("{}\nd COMPARE_COMPILED_CODE",
  c.get_toy0_source_code());
  context.type_keys(vec!["F10"]);
  context.store_text(ram_command_source, &c_source);
}

\rs{code(&c_source)}

\noindent Then type Escape and ``s'' to save it. Finally, type ``r'' to run it.
The result should be 0, indicating that the two compiler versions produced the
same compiled code. If this is not the case, repeat the steps from ``Edit v2''
until this test passes. It might also happen that the $1^{st}$ version is wrong
despite the ``Test v1'' step. In this case type ``F8''+``r'' to restore the
types compiler and restart from the ``Edit v1'' step.

\rust{
  context.type_keys(vec!["S"]);
  context.type_ascii("R");
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");

  let compiler_code_backup =
      context.memory_region("compiler_code_backup").start;
  let define_address = |name, value| {
    define(name, &hex(context.memory_region(value).start))
  };
}

\begin{Figure}
\rs{define_address("mmapa", "interpreter")}
\rs{define_address("mmapb", "clock_driver")}
\rs{define_address("mmapc", "graphics_card_driver")}
\rs{define_address("mmapd", "keyboard_driver")}
\rs{define_address("mmape", "memory_editor")}
\rs{define_address("mmapf", "flash_driver")}
\rs{define_address("mmapg", "text_editor")}
\rs{define_address("mmaph", "toyc0")}
\rs{define_address("mmapi", "command_editor")}
\rs{define_address("mmapj", "compiler_code")}
\rs{define_address("mmapk", "command_editor_commands")}
\rs{define_address("mmapl", "compiler_source")}
\rs{define_address("mmapm", "compiler_code_backup")}
\input{figures/chapter8/final-memory-map.tex}

\caption{The flash memory content at the end of \cref{part:compiler}. White,
blue, red, and gray areas represent source code, bytecode, native code, and
unused memory, respectively (not to scale).}\label{fig:final-toyc-memory-map}
\end{Figure}

In the next part we need both the types compiler and the native compiler, to
produce either bytecode or native code. We currently have a backup of the
former at address \rs{hex(compiler_code_backup)}, and two copies of the latter
at addresses \rs{hex(ram_compiler_code)} and \rs{hex(dst_buffer)}. However, the
types compiler code is not position independent and cannot be used from address
\rs{hex(compiler_code_backup)}. To copy it to its original address, restore its
backup by typing ``F8''+``r''. We can then replace this backup, starting at page
\rs{dec(page_number(compiler_code_backup))}, with the native compiler. For this
type ``F8''+``e'' to edit this command and replace it with the following:

\rust{
  // Restore Types compiler v2, overrides native compiler v1.
  context.type_keys(vec!["F8"]);
  context.type_ascii("R\n");

  context.type_keys(vec!["F8"]);
  let mut c = BytecodeAssembler::default();
  c.import_labels(context.memory_region("flash_driver"));
  c.func("save_compiled_code", &[], "", &[]);
  c.new_line();
  c.cst(ram_compiler_code);
  c.cst(page_number(compiler_code_backup));
  c.call("buffer_flash");
  c.new_line();
  c.cst_0();
  c.retv();
  let c_source = format!("{}\nd STORE_COMPILED_CODE", c.get_toy0_source_code());
  context.store_text(ram_command_source, &c_source);
  // type Escape after edit, then type 'R' to run it
  context.type_keys(vec!["R"]);
  assert_eq!(display.borrow().get_text(), "00000000");
  context.type_ascii("\n");
}

\rs{code(&c_source)}

The type Escape and ``r'' to run it. At this stage the flash memory content is
the one depicted in \cref{fig:final-toyc-memory-map}.
